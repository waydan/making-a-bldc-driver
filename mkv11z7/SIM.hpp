// This file was automatically generated by the Regilite generator


#ifndef MKV11Z7_SIM_HPP
#define MKV11Z7_SIM_HPP

#include <cstdint>
#include <regilite/default_register.hpp>
#include <regilite/field.hpp>


namespace MKV11Z7 {
inline namespace SIM {


inline namespace SOPT1_ {

enum class OSC32KSEL_e : std::uint8_t
{
    OSC32CLK = 0, // System oscillator (OSC32KCLK)
    LPO_1KHZ = 3  // LPO 1 kHz
};
using OSC32KSEL_ = Field<OSC32KSEL_e, Mask<19, 18>{}, RW, struct SOPT1_>;
// 32K Oscillator Clock Select
struct OSC32KSEL : OSC32KSEL_ {
    explicit constexpr OSC32KSEL(OSC32KSEL_e value) : OSC32KSEL_(value) {}
    static constexpr OSC32KSEL_ OSC32CLK{
        OSC32KSEL_e::OSC32CLK}; // System oscillator (OSC32KCLK)
    static constexpr OSC32KSEL_ LPO_1KHZ{OSC32KSEL_e::LPO_1KHZ}; // LPO 1 kHz
};
using reg = Register<std::uint32_t, 0x0, OSC32KSEL_>;
} // namespace SOPT1_


inline namespace SOPT2_ {

enum class CLKOUTSEL_e : std::uint8_t
{
    BUS_CLOCK = 2, // Bus clock
    LPO_1KHZ = 3,  // LPO clock (1 kHz)
    MCGIRCLK = 4,  // MCGIRCLK
    OSCERCLK = 6   // OSCERCLK
};
using CLKOUTSEL_ = Field<CLKOUTSEL_e, Mask<7, 5>{}, RW, struct SOPT2_>;
// CLKOUT Select
struct CLKOUTSEL : CLKOUTSEL_ {
    explicit constexpr CLKOUTSEL(CLKOUTSEL_e value) : CLKOUTSEL_(value) {}
    static constexpr CLKOUTSEL_ BUS_CLOCK{CLKOUTSEL_e::BUS_CLOCK}; // Bus clock
    static constexpr CLKOUTSEL_ LPO_1KHZ{
        CLKOUTSEL_e::LPO_1KHZ}; // LPO clock (1 kHz)
    static constexpr CLKOUTSEL_ MCGIRCLK{CLKOUTSEL_e::MCGIRCLK}; // MCGIRCLK
    static constexpr CLKOUTSEL_ OSCERCLK{CLKOUTSEL_e::OSCERCLK}; // OSCERCLK
};

enum class FTMFFCLKSEL_e : std::uint8_t
{
    MCGFFCLK = 0, // MCGFFCLK
    MCGIRCLK = 1, // MCGIRCLK
    OSCERCLK = 2, // OSCERCLK
    MCGFFCLK = 3  // MCGFFCLK
};
using FTMFFCLKSEL_ = Field<FTMFFCLKSEL_e, Mask<25, 24>{}, RW, struct SOPT2_>;
// FTM Fixed Frequency Clock Select
struct FTMFFCLKSEL : FTMFFCLKSEL_ {
    explicit constexpr FTMFFCLKSEL(FTMFFCLKSEL_e value) : FTMFFCLKSEL_(value) {}
    static constexpr FTMFFCLKSEL_ MCGFFCLK{FTMFFCLKSEL_e::MCGFFCLK}; // MCGFFCLK
    static constexpr FTMFFCLKSEL_ MCGIRCLK{FTMFFCLKSEL_e::MCGIRCLK}; // MCGIRCLK
    static constexpr FTMFFCLKSEL_ OSCERCLK{FTMFFCLKSEL_e::OSCERCLK}; // OSCERCLK
    static constexpr FTMFFCLKSEL_ MCGFFCLK{FTMFFCLKSEL_e::MCGFFCLK}; // MCGFFCLK
};
using reg = Register<std::uint32_t, 0x0, CLKOUTSEL_, FTMFFCLKSEL_>;
} // namespace SOPT2_


inline namespace SOPT4_ {

enum class FTM0FLT0_e : std::uint8_t
{
    FTM0_FLT0 = 0, // FTM0_FLT0 pin
    CMP0 = 1       // CMP0 out
};
using FTM0FLT0_ = Field<FTM0FLT0_e, Mask<0>{}, RW, struct SOPT4_>;
// FTM0 Fault 0 Select
struct FTM0FLT0 : FTM0FLT0_ {
    explicit constexpr FTM0FLT0(FTM0FLT0_e value) : FTM0FLT0_(value) {}
    static constexpr FTM0FLT0_ FTM0_FLT0{
        FTM0FLT0_e::FTM0_FLT0};                        // FTM0_FLT0 pin
    static constexpr FTM0FLT0_ CMP0{FTM0FLT0_e::CMP0}; // CMP0 out
};

enum class FTM0FLT1_e : std::uint8_t
{
    FTM0_FLT1 = 0, // FTM0_FLT1 pin
    CMP1 = 1       // CMP1 out
};
using FTM0FLT1_ = Field<FTM0FLT1_e, Mask<1>{}, RW, struct SOPT4_>;
// FTM0 Fault 1 Select
struct FTM0FLT1 : FTM0FLT1_ {
    explicit constexpr FTM0FLT1(FTM0FLT1_e value) : FTM0FLT1_(value) {}
    static constexpr FTM0FLT1_ FTM0_FLT1{
        FTM0FLT1_e::FTM0_FLT1};                        // FTM0_FLT1 pin
    static constexpr FTM0FLT1_ CMP1{FTM0FLT1_e::CMP1}; // CMP1 out
};

enum class FTM1FLT0_e : std::uint8_t
{
    FTM1_FLT0 = 0, // FTM1_FLT0 pin
    CMP0 = 1       // CMP0 out
};
using FTM1FLT0_ = Field<FTM1FLT0_e, Mask<2>{}, RW, struct SOPT4_>;
// FTM1 Fault 0 Select
struct FTM1FLT0 : FTM1FLT0_ {
    explicit constexpr FTM1FLT0(FTM1FLT0_e value) : FTM1FLT0_(value) {}
    static constexpr FTM1FLT0_ FTM1_FLT0{
        FTM1FLT0_e::FTM1_FLT0};                        // FTM1_FLT0 pin
    static constexpr FTM1FLT0_ CMP0{FTM1FLT0_e::CMP0}; // CMP0 out
};

enum class FTM2FLT0_e : std::uint8_t
{
    FTM2FLT0 = 0, // FTM2_FLT0 pin
    CMP0 = 1      // CMP0 out
};
using FTM2FLT0_ = Field<FTM2FLT0_e, Mask<3>{}, RW, struct SOPT4_>;
// FTM2 Fault 0 Select
struct FTM2FLT0 : FTM2FLT0_ {
    explicit constexpr FTM2FLT0(FTM2FLT0_e value) : FTM2FLT0_(value) {}
    static constexpr FTM2FLT0_ FTM2FLT0{FTM2FLT0_e::FTM2FLT0}; // FTM2_FLT0 pin
    static constexpr FTM2FLT0_ CMP0{FTM2FLT0_e::CMP0};         // CMP0 out
};

enum class FTM0TRG0SRC_e : std::uint8_t
{
    CMP0 = 0, // CMP0 output drives FTM0 hardware trigger 0
    FTM1 = 1  // FTM1 channel match drives FTM0 hardware trigger 0
};
using FTM0TRG0SRC_ = Field<FTM0TRG0SRC_e, Mask<7>{}, RW, struct SOPT4_>;
// FlexTimer 0 Hardware Trigger 0 Source Select
struct FTM0TRG0SRC : FTM0TRG0SRC_ {
    explicit constexpr FTM0TRG0SRC(FTM0TRG0SRC_e value) : FTM0TRG0SRC_(value) {}
    static constexpr FTM0TRG0SRC_ CMP0{
        FTM0TRG0SRC_e::CMP0}; // CMP0 output drives FTM0 hardware trigger 0
    static constexpr FTM0TRG0SRC_ FTM1{
        FTM0TRG0SRC_e::FTM1}; // FTM1 channel match drives FTM0 hardware trigger
                              // 0
};

enum class FTM0TRG1SRC_e : std::uint8_t
{
    PDB_CH1 = 0, // PDB0 channel 1 trigger drives FTM0 hardware trigger 1
    FTM2 = 1     // FTM2 channel match drives FTM0 hardware trigger 1
};
using FTM0TRG1SRC_ = Field<FTM0TRG1SRC_e, Mask<8>{}, RW, struct SOPT4_>;
// FlexTimer 0 Hardware Trigger 1 Source Select
struct FTM0TRG1SRC : FTM0TRG1SRC_ {
    explicit constexpr FTM0TRG1SRC(FTM0TRG1SRC_e value) : FTM0TRG1SRC_(value) {}
    static constexpr FTM0TRG1SRC_ PDB_CH1{
        FTM0TRG1SRC_e::PDB_CH1}; // PDB0 channel 1 trigger drives FTM0 hardware
                                 // trigger 1
    static constexpr FTM0TRG1SRC_ FTM2{
        FTM0TRG1SRC_e::FTM2}; // FTM2 channel match drives FTM0 hardware trigger
                              // 1
};

enum class FTM0TRG2SRC_e : std::uint8_t
{
    CMP0 = 0, // CMP0 output drives FTM0 hardware trigger 2
    CMP1 = 1  // CMP1 output drives FTM0 hardware trigger 2
};
using FTM0TRG2SRC_ = Field<FTM0TRG2SRC_e, Mask<9>{}, RW, struct SOPT4_>;
// FlexTimer 0 Hardware Trigger 2 Source Select
struct FTM0TRG2SRC : FTM0TRG2SRC_ {
    explicit constexpr FTM0TRG2SRC(FTM0TRG2SRC_e value) : FTM0TRG2SRC_(value) {}
    static constexpr FTM0TRG2SRC_ CMP0{
        FTM0TRG2SRC_e::CMP0}; // CMP0 output drives FTM0 hardware trigger 2
    static constexpr FTM0TRG2SRC_ CMP1{
        FTM0TRG2SRC_e::CMP1}; // CMP1 output drives FTM0 hardware trigger 2
};

enum class FTM1TRG0SRC_e : std::uint8_t
{
    CMP0 = 0, // CMP0 output drives FTM1 hardware trigger 0
    FTM0 = 1  // FTM0 channel match drives FTM1 hardware trigger 0
};
using FTM1TRG0SRC_ = Field<FTM1TRG0SRC_e, Mask<10>{}, RW, struct SOPT4_>;
// FlexTimer 1 Hardware Trigger 0 Source Select
struct FTM1TRG0SRC : FTM1TRG0SRC_ {
    explicit constexpr FTM1TRG0SRC(FTM1TRG0SRC_e value) : FTM1TRG0SRC_(value) {}
    static constexpr FTM1TRG0SRC_ CMP0{
        FTM1TRG0SRC_e::CMP0}; // CMP0 output drives FTM1 hardware trigger 0
    static constexpr FTM1TRG0SRC_ FTM0{
        FTM1TRG0SRC_e::FTM0}; // FTM0 channel match drives FTM1 hardware trigger
                              // 0
};

enum class FTM1TRG1SRC_e : std::uint8_t
{
    PDB0_CH1 = 0, // PDB0 channel 1 trigger drives FTM1 hardware trigger 1
    FTM2 = 1      // FTM2 channel match drives FTM1 hardware trigger 1
};
using FTM1TRG1SRC_ = Field<FTM1TRG1SRC_e, Mask<11>{}, RW, struct SOPT4_>;
// FlexTimer 1 Hardware Trigger 1 Source Select
struct FTM1TRG1SRC : FTM1TRG1SRC_ {
    explicit constexpr FTM1TRG1SRC(FTM1TRG1SRC_e value) : FTM1TRG1SRC_(value) {}
    static constexpr FTM1TRG1SRC_ PDB0_CH1{
        FTM1TRG1SRC_e::PDB0_CH1}; // PDB0 channel 1 trigger drives FTM1 hardware
                                  // trigger 1
    static constexpr FTM1TRG1SRC_ FTM2{
        FTM1TRG1SRC_e::FTM2}; // FTM2 channel match drives FTM1 hardware trigger
                              // 1
};

enum class FTM1TRG2SRC_e : std::uint8_t
{
    CMP0 = 0, // CMP0 output drives FTM1 hardware trigger 2
    CMP1 = 1  // CMP1 output drives FTM1 hardware trigger 2
};
using FTM1TRG2SRC_ = Field<FTM1TRG2SRC_e, Mask<12>{}, RW, struct SOPT4_>;
// FlexTimer 1 Hardware Trigger 2 Source Select
struct FTM1TRG2SRC : FTM1TRG2SRC_ {
    explicit constexpr FTM1TRG2SRC(FTM1TRG2SRC_e value) : FTM1TRG2SRC_(value) {}
    static constexpr FTM1TRG2SRC_ CMP0{
        FTM1TRG2SRC_e::CMP0}; // CMP0 output drives FTM1 hardware trigger 2
    static constexpr FTM1TRG2SRC_ CMP1{
        FTM1TRG2SRC_e::CMP1}; // CMP1 output drives FTM1 hardware trigger 2
};

enum class FTM2TRG0SRC_e : std::uint8_t
{
    CMP0 = 0, // CMP0 output drives FTM2 hardware trigger 0
    FTM0 = 1  // FTM0 channel match drives FTM2 hardware trigger 0
};
using FTM2TRG0SRC_ = Field<FTM2TRG0SRC_e, Mask<13>{}, RW, struct SOPT4_>;
// FlexTimer 2 Hardware Trigger 0 Source Select
struct FTM2TRG0SRC : FTM2TRG0SRC_ {
    explicit constexpr FTM2TRG0SRC(FTM2TRG0SRC_e value) : FTM2TRG0SRC_(value) {}
    static constexpr FTM2TRG0SRC_ CMP0{
        FTM2TRG0SRC_e::CMP0}; // CMP0 output drives FTM2 hardware trigger 0
    static constexpr FTM2TRG0SRC_ FTM0{
        FTM2TRG0SRC_e::FTM0}; // FTM0 channel match drives FTM2 hardware trigger
                              // 0
};

enum class FTM2TRG1SRC_e : std::uint8_t
{
    PDB0_OT1 = 0, // PDB0 output trigger 1 drives FTM2 hardware trigger 1
    FTM1 = 1      // FTM1 channel match drives FTM2 hardware trigger 1
};
using FTM2TRG1SRC_ = Field<FTM2TRG1SRC_e, Mask<14>{}, RW, struct SOPT4_>;
// FlexTimer 2 Hardware Trigger 1 Source Select
struct FTM2TRG1SRC : FTM2TRG1SRC_ {
    explicit constexpr FTM2TRG1SRC(FTM2TRG1SRC_e value) : FTM2TRG1SRC_(value) {}
    static constexpr FTM2TRG1SRC_ PDB0_OT1{
        FTM2TRG1SRC_e::PDB0_OT1}; // PDB0 output trigger 1 drives FTM2 hardware
                                  // trigger 1
    static constexpr FTM2TRG1SRC_ FTM1{
        FTM2TRG1SRC_e::FTM1}; // FTM1 channel match drives FTM2 hardware trigger
                              // 1
};

enum class FTM2TRG2SRC_e : std::uint8_t
{
    CMP0 = 0, // CMP0 output drives FTM2 hardware trigger 2
    CMP1 = 1  // CMP1 output drives FTM2 hardware trigger 2
};
using FTM2TRG2SRC_ = Field<FTM2TRG2SRC_e, Mask<15>{}, RW, struct SOPT4_>;
// FlexTimer 2 Hardware Trigger 2 Source Select
struct FTM2TRG2SRC : FTM2TRG2SRC_ {
    explicit constexpr FTM2TRG2SRC(FTM2TRG2SRC_e value) : FTM2TRG2SRC_(value) {}
    static constexpr FTM2TRG2SRC_ CMP0{
        FTM2TRG2SRC_e::CMP0}; // CMP0 output drives FTM2 hardware trigger 2
    static constexpr FTM2TRG2SRC_ CMP1{
        FTM2TRG2SRC_e::CMP1}; // CMP1 output drives FTM2 hardware trigger 2
};

enum class FTM1CH0SRC_e : std::uint8_t
{
    FTM1_CH0 = 0, // FTM1_CH0 signal
    CMP0 = 1,     // CMP0 output
    CMP1 = 2      // CMP1 output
};
using FTM1CH0SRC_ = Field<FTM1CH0SRC_e, Mask<19, 18>{}, RW, struct SOPT4_>;
// FTM1 Channel 0 Input Capture Source Select
struct FTM1CH0SRC : FTM1CH0SRC_ {
    explicit constexpr FTM1CH0SRC(FTM1CH0SRC_e value) : FTM1CH0SRC_(value) {}
    static constexpr FTM1CH0SRC_ FTM1_CH0{
        FTM1CH0SRC_e::FTM1_CH0};                           // FTM1_CH0 signal
    static constexpr FTM1CH0SRC_ CMP0{FTM1CH0SRC_e::CMP0}; // CMP0 output
    static constexpr FTM1CH0SRC_ CMP1{FTM1CH0SRC_e::CMP1}; // CMP1 output
};

enum class FTM2CH0SRC_e : std::uint8_t
{
    FTM2_CH2 = 0, // FTM2_CH0 signal
    CMP0 = 1,     // CMP0 output
    CMP1 = 2      // CMP1 output
};
using FTM2CH0SRC_ = Field<FTM2CH0SRC_e, Mask<21, 20>{}, RW, struct SOPT4_>;
// FTM2 Channel 0 Input Capture Source Select
struct FTM2CH0SRC : FTM2CH0SRC_ {
    explicit constexpr FTM2CH0SRC(FTM2CH0SRC_e value) : FTM2CH0SRC_(value) {}
    static constexpr FTM2CH0SRC_ FTM2_CH2{
        FTM2CH0SRC_e::FTM2_CH2};                           // FTM2_CH0 signal
    static constexpr FTM2CH0SRC_ CMP0{FTM2CH0SRC_e::CMP0}; // CMP0 output
    static constexpr FTM2CH0SRC_ CMP1{FTM2CH0SRC_e::CMP1}; // CMP1 output
};

enum class FTM2CH1SRC_e : std::uint8_t
{
    v0 = 0, // FTM2_CH1 pin is fed to FTM2 CH1
    v1 = 1  // FTM2_CH1 pin XOR FTM2_CH0 pin XOR FTM1_CH1 pin is fed to FTM2 CH1
            // If this field is set, then the three input pins feed FTM2 channel
            // 1 input capture. In this case, FTM1 channel 1 cannot be used for
    // input capture of FTM1, as it has no pin. FTM1 channel1 can be used
    // for Output Compare mode of FTM1, though without an output.
};
using FTM2CH1SRC_ = Field<FTM2CH1SRC_e, Mask<22>{}, RW, struct SOPT4_>;
// FTM2 Channel 1 Input Capture Source Select
struct FTM2CH1SRC : FTM2CH1SRC_ {
    explicit constexpr FTM2CH1SRC(FTM2CH1SRC_e value) : FTM2CH1SRC_(value) {}
    static constexpr FTM2CH1SRC_ v0{
        FTM2CH1SRC_e::v0}; // FTM2_CH1 pin is fed to FTM2 CH1
    static constexpr FTM2CH1SRC_ v1{
        FTM2CH1SRC_e::v1}; // FTM2_CH1 pin XOR FTM2_CH0 pin XOR FTM1_CH1 pin is
                           // fed to FTM2 CH1 If this field is set, then the
                           // three input pins feed FTM2 channel 1 input
                           // capture. In this case, FTM1 channel 1 cannot be
                           // used for input capture of FTM1, as it has no pin.
                           // FTM1 channel1 can be used for Output Compare mode
                           // of FTM1, though without an output.
};

enum class FTM0CLKSEL_e : std::uint8_t
{
    v00 = 0, // FTM0 external clock driven by FTM_CLKIN0 pin
    v01 = 1, // FTM0 external clock driven by FTM_CLKIN1 pin
    v10 = 2  // FTM0 external clock driven by FTM_CLKIN2 pin
};
using FTM0CLKSEL_ = Field<FTM0CLKSEL_e, Mask<25, 24>{}, RW, struct SOPT4_>;
// FTM0 External Clock Pin Select
struct FTM0CLKSEL : FTM0CLKSEL_ {
    explicit constexpr FTM0CLKSEL(FTM0CLKSEL_e value) : FTM0CLKSEL_(value) {}
    static constexpr FTM0CLKSEL_ v00{
        FTM0CLKSEL_e::v00}; // FTM0 external clock driven by FTM_CLKIN0 pin
    static constexpr FTM0CLKSEL_ v01{
        FTM0CLKSEL_e::v01}; // FTM0 external clock driven by FTM_CLKIN1 pin
    static constexpr FTM0CLKSEL_ v10{
        FTM0CLKSEL_e::v10}; // FTM0 external clock driven by FTM_CLKIN2 pin
};

enum class FTM1CLKSEL_e : std::uint8_t
{
    v00 = 0, // FTM1 external clock driven by FTM_CLKIN0 pin
    v01 = 1, // FTM1 external clock driven by FTM_CLKIN1 pin
    v10 = 2  // FTM1 external clock driven by FTM_CLKIN2 pin
};
using FTM1CLKSEL_ = Field<FTM1CLKSEL_e, Mask<27, 26>{}, RW, struct SOPT4_>;
// FTM1 External Clock Pin Select
struct FTM1CLKSEL : FTM1CLKSEL_ {
    explicit constexpr FTM1CLKSEL(FTM1CLKSEL_e value) : FTM1CLKSEL_(value) {}
    static constexpr FTM1CLKSEL_ v00{
        FTM1CLKSEL_e::v00}; // FTM1 external clock driven by FTM_CLKIN0 pin
    static constexpr FTM1CLKSEL_ v01{
        FTM1CLKSEL_e::v01}; // FTM1 external clock driven by FTM_CLKIN1 pin
    static constexpr FTM1CLKSEL_ v10{
        FTM1CLKSEL_e::v10}; // FTM1 external clock driven by FTM_CLKIN2 pin
};

enum class FTM2CLKSEL_e : std::uint8_t
{
    v00 = 0, // FTM2 external clock driven by FTM_CLKIN0 pin
    v01 = 1, // FTM2 external clock driven by FTM_CLKIN1 pin
    v10 = 2  // FTM2 external clock driven by FTM_CLKIN2 pin
};
using FTM2CLKSEL_ = Field<FTM2CLKSEL_e, Mask<29, 28>{}, RW, struct SOPT4_>;
// FTM2 External Clock Pin Select
struct FTM2CLKSEL : FTM2CLKSEL_ {
    explicit constexpr FTM2CLKSEL(FTM2CLKSEL_e value) : FTM2CLKSEL_(value) {}
    static constexpr FTM2CLKSEL_ v00{
        FTM2CLKSEL_e::v00}; // FTM2 external clock driven by FTM_CLKIN0 pin
    static constexpr FTM2CLKSEL_ v01{
        FTM2CLKSEL_e::v01}; // FTM2 external clock driven by FTM_CLKIN1 pin
    static constexpr FTM2CLKSEL_ v10{
        FTM2CLKSEL_e::v10}; // FTM2 external clock driven by FTM_CLKIN2 pin
};
using reg = Register<std::uint32_t, 0x0, FTM0FLT0_, FTM0FLT1_, FTM1FLT0_,
                     FTM2FLT0_, FTM0TRG0SRC_, FTM0TRG1SRC_, FTM0TRG2SRC_,
                     FTM1TRG0SRC_, FTM1TRG1SRC_, FTM1TRG2SRC_, FTM2TRG0SRC_,
                     FTM2TRG1SRC_, FTM2TRG2SRC_, FTM1CH0SRC_, FTM2CH0SRC_,
                     FTM2CH1SRC_, FTM0CLKSEL_, FTM1CLKSEL_, FTM2CLKSEL_>;
} // namespace SOPT4_


inline namespace SOPT5_ {

enum class UART0TXSRC_e : std::uint8_t
{
    v00 = 0, // UART0_TX pin
    v01 = 1, // UART0_TX pin modulated with FTM1 channel 0 output
    v10 = 2  // UART0_TX pin modulated with FTM2 channel 0 output
};
using UART0TXSRC_ = Field<UART0TXSRC_e, Mask<1, 0>{}, RW, struct SOPT5_>;
// UART 0 Transmit Data Source Select
struct UART0TXSRC : UART0TXSRC_ {
    explicit constexpr UART0TXSRC(UART0TXSRC_e value) : UART0TXSRC_(value) {}
    static constexpr UART0TXSRC_ v00{UART0TXSRC_e::v00}; // UART0_TX pin
    static constexpr UART0TXSRC_ v01{
        UART0TXSRC_e::v01}; // UART0_TX pin modulated with FTM1 channel 0 output
    static constexpr UART0TXSRC_ v10{
        UART0TXSRC_e::v10}; // UART0_TX pin modulated with FTM2 channel 0 output
};

enum class UART0RXSRC_e : std::uint8_t
{
    v00 = 0, // UART0_RX pin
    v01 = 1, // CMP0
    v10 = 2  // CMP1
};
using UART0RXSRC_ = Field<UART0RXSRC_e, Mask<3, 2>{}, RW, struct SOPT5_>;
// UART 0 Receive Data Source Select
struct UART0RXSRC : UART0RXSRC_ {
    explicit constexpr UART0RXSRC(UART0RXSRC_e value) : UART0RXSRC_(value) {}
    static constexpr UART0RXSRC_ v00{UART0RXSRC_e::v00}; // UART0_RX pin
    static constexpr UART0RXSRC_ v01{UART0RXSRC_e::v01}; // CMP0
    static constexpr UART0RXSRC_ v10{UART0RXSRC_e::v10}; // CMP1
};

enum class UART1TXSRC_e : std::uint8_t
{
    v00 = 0, // UART1_TX pin
    v01 = 1, // UART1_TX pin modulated with FTM1 channel 0 output
    v10 = 2  // UART1_TX pin modulated with FTM2 channel 0 output
};
using UART1TXSRC_ = Field<UART1TXSRC_e, Mask<5, 4>{}, RW, struct SOPT5_>;
// UART 1 Transmit Data Source Select
struct UART1TXSRC : UART1TXSRC_ {
    explicit constexpr UART1TXSRC(UART1TXSRC_e value) : UART1TXSRC_(value) {}
    static constexpr UART1TXSRC_ v00{UART1TXSRC_e::v00}; // UART1_TX pin
    static constexpr UART1TXSRC_ v01{
        UART1TXSRC_e::v01}; // UART1_TX pin modulated with FTM1 channel 0 output
    static constexpr UART1TXSRC_ v10{
        UART1TXSRC_e::v10}; // UART1_TX pin modulated with FTM2 channel 0 output
};

enum class UART1RXSRC_e : std::uint8_t
{
    v00 = 0, // UART1_RX pin
    v01 = 1, // CMP0
    v10 = 2  // CMP1
};
using UART1RXSRC_ = Field<UART1RXSRC_e, Mask<7, 6>{}, RW, struct SOPT5_>;
// UART 1 Receive Data Source Select
struct UART1RXSRC : UART1RXSRC_ {
    explicit constexpr UART1RXSRC(UART1RXSRC_e value) : UART1RXSRC_(value) {}
    static constexpr UART1RXSRC_ v00{UART1RXSRC_e::v00}; // UART1_RX pin
    static constexpr UART1RXSRC_ v01{UART1RXSRC_e::v01}; // CMP0
    static constexpr UART1RXSRC_ v10{UART1RXSRC_e::v10}; // CMP1
};

enum class UART0ODE_e : std::uint8_t
{
    v0 = 0, // Open drain is disabled on UART0
    v1 = 1  // Open drain is enabled on UART0
};
using UART0ODE_ = Field<UART0ODE_e, Mask<16>{}, RW, struct SOPT5_>;
// UART0 Open Drain Enable
struct UART0ODE : UART0ODE_ {
    explicit constexpr UART0ODE(UART0ODE_e value) : UART0ODE_(value) {}
    static constexpr UART0ODE_ v0{
        UART0ODE_e::v0}; // Open drain is disabled on UART0
    static constexpr UART0ODE_ v1{
        UART0ODE_e::v1}; // Open drain is enabled on UART0
};

enum class UART1ODE_e : std::uint8_t
{
    v0 = 0, // Open drain is disabled on UART1
    v1 = 1  // Open drain is enabled on UART1
};
using UART1ODE_ = Field<UART1ODE_e, Mask<17>{}, RW, struct SOPT5_>;
// UART1 Open Drain Enable
struct UART1ODE : UART1ODE_ {
    explicit constexpr UART1ODE(UART1ODE_e value) : UART1ODE_(value) {}
    static constexpr UART1ODE_ v0{
        UART1ODE_e::v0}; // Open drain is disabled on UART1
    static constexpr UART1ODE_ v1{
        UART1ODE_e::v1}; // Open drain is enabled on UART1
};
using reg = Register<std::uint32_t, 0x0, UART0TXSRC_, UART0RXSRC_, UART1TXSRC_,
                     UART1RXSRC_, UART0ODE_, UART1ODE_>;
} // namespace SOPT5_


inline namespace SOPT6_ {

enum class FTM3FLT0_e : std::uint8_t
{
    v0 = 0, // FTM3_FLT0 pin
    v1 = 1  // CMP0 out
};
using FTM3FLT0_ = Field<FTM3FLT0_e, Mask<0>{}, RW, struct SOPT6_>;
// FTM3 Fault 0 Select
struct FTM3FLT0 : FTM3FLT0_ {
    explicit constexpr FTM3FLT0(FTM3FLT0_e value) : FTM3FLT0_(value) {}
    static constexpr FTM3FLT0_ v0{FTM3FLT0_e::v0}; // FTM3_FLT0 pin
    static constexpr FTM3FLT0_ v1{FTM3FLT0_e::v1}; // CMP0 out
};

enum class FTM4FLT0_e : std::uint8_t
{
    v0 = 0, // FTM4_FLT0 pin
    v1 = 1  // CMP0 out
};
using FTM4FLT0_ = Field<FTM4FLT0_e, Mask<2>{}, RW, struct SOPT6_>;
// FTM4 Fault 0 Select
struct FTM4FLT0 : FTM4FLT0_ {
    explicit constexpr FTM4FLT0(FTM4FLT0_e value) : FTM4FLT0_(value) {}
    static constexpr FTM4FLT0_ v0{FTM4FLT0_e::v0}; // FTM4_FLT0 pin
    static constexpr FTM4FLT0_ v1{FTM4FLT0_e::v1}; // CMP0 out
};

enum class FTM5FLT0_e : std::uint8_t
{
    v0 = 0, // FTM5_FLT0 pin
    v1 = 1  // CMP0 out
};
using FTM5FLT0_ = Field<FTM5FLT0_e, Mask<3>{}, RW, struct SOPT6_>;
// FTM5 Fault 0 Select
struct FTM5FLT0 : FTM5FLT0_ {
    explicit constexpr FTM5FLT0(FTM5FLT0_e value) : FTM5FLT0_(value) {}
    static constexpr FTM5FLT0_ v0{FTM5FLT0_e::v0}; // FTM5_FLT0 pin
    static constexpr FTM5FLT0_ v1{FTM5FLT0_e::v1}; // CMP0 out
};

enum class FTM3TRG0SRC_e : std::uint8_t
{
    v0 = 0, // CMP0 output drives FTM3 hardware trigger 0
    v1 = 1  // FTM5 channel match drives FTM3 hardware trigger 0
};
using FTM3TRG0SRC_ = Field<FTM3TRG0SRC_e, Mask<7>{}, RW, struct SOPT6_>;
// FlexTimer 3 Hardware Trigger 0 Source Select
struct FTM3TRG0SRC : FTM3TRG0SRC_ {
    explicit constexpr FTM3TRG0SRC(FTM3TRG0SRC_e value) : FTM3TRG0SRC_(value) {}
    static constexpr FTM3TRG0SRC_ v0{
        FTM3TRG0SRC_e::v0}; // CMP0 output drives FTM3 hardware trigger 0
    static constexpr FTM3TRG0SRC_ v1{
        FTM3TRG0SRC_e::v1}; // FTM5 channel match drives FTM3 hardware trigger 0
};

enum class FTM3TRG1SRC_e : std::uint8_t
{
    v0 = 0, // PDB1 output drives FTM3 hardware trigger 1
    v1 = 1  // FTM4 channel match drives FTM3 hardware trigger 1
};
using FTM3TRG1SRC_ = Field<FTM3TRG1SRC_e, Mask<8>{}, RW, struct SOPT6_>;
// FlexTimer 3 Hardware Trigger 1 Source Select
struct FTM3TRG1SRC : FTM3TRG1SRC_ {
    explicit constexpr FTM3TRG1SRC(FTM3TRG1SRC_e value) : FTM3TRG1SRC_(value) {}
    static constexpr FTM3TRG1SRC_ v0{
        FTM3TRG1SRC_e::v0}; // PDB1 output drives FTM3 hardware trigger 1
    static constexpr FTM3TRG1SRC_ v1{
        FTM3TRG1SRC_e::v1}; // FTM4 channel match drives FTM3 hardware trigger 1
};

enum class FTM3TRG2SRC_e : std::uint8_t
{
    v0 = 0, // CMP0 output drives FTM3 hardware trigger 2
    v1 = 1  // CMP1 output drives FTM3 hardware trigger 2
};
using FTM3TRG2SRC_ = Field<FTM3TRG2SRC_e, Mask<9>{}, RW, struct SOPT6_>;
// FlexTimer 3 Hardware Trigger 2 Source Select
struct FTM3TRG2SRC : FTM3TRG2SRC_ {
    explicit constexpr FTM3TRG2SRC(FTM3TRG2SRC_e value) : FTM3TRG2SRC_(value) {}
    static constexpr FTM3TRG2SRC_ v0{
        FTM3TRG2SRC_e::v0}; // CMP0 output drives FTM3 hardware trigger 2
    static constexpr FTM3TRG2SRC_ v1{
        FTM3TRG2SRC_e::v1}; // CMP1 output drives FTM3 hardware trigger 2
};

enum class FTM4TRG0SRC_e : std::uint8_t
{
    v0 = 0, // CMP0 output drives FTM4 hardware trigger 0
    v1 = 1  // FTM3 channel match drives FTM4 hardware trigger 0
};
using FTM4TRG0SRC_ = Field<FTM4TRG0SRC_e, Mask<10>{}, RW, struct SOPT6_>;
// FlexTimer 4 Hardware Trigger 0 Source Select
struct FTM4TRG0SRC : FTM4TRG0SRC_ {
    explicit constexpr FTM4TRG0SRC(FTM4TRG0SRC_e value) : FTM4TRG0SRC_(value) {}
    static constexpr FTM4TRG0SRC_ v0{
        FTM4TRG0SRC_e::v0}; // CMP0 output drives FTM4 hardware trigger 0
    static constexpr FTM4TRG0SRC_ v1{
        FTM4TRG0SRC_e::v1}; // FTM3 channel match drives FTM4 hardware trigger 0
};

enum class FTM4TRG1SRC_e : std::uint8_t
{
    v0 = 0, // PDB1 output trigger 1 drives FTM4 hardware trigger 1
    v1 = 1  // FTM5 channel match drives FTM4 hardware trigger 1
};
using FTM4TRG1SRC_ = Field<FTM4TRG1SRC_e, Mask<11>{}, RW, struct SOPT6_>;
// FlexTimer 4 Hardware Trigger 1 Source Select
struct FTM4TRG1SRC : FTM4TRG1SRC_ {
    explicit constexpr FTM4TRG1SRC(FTM4TRG1SRC_e value) : FTM4TRG1SRC_(value) {}
    static constexpr FTM4TRG1SRC_ v0{
        FTM4TRG1SRC_e::v0}; // PDB1 output trigger 1 drives FTM4 hardware
                            // trigger 1
    static constexpr FTM4TRG1SRC_ v1{
        FTM4TRG1SRC_e::v1}; // FTM5 channel match drives FTM4 hardware trigger 1
};

enum class FTM4TRG2SRC_e : std::uint8_t
{
    v0 = 0, // CMP0 output drives FTM4 hardware trigger 2
    v1 = 1  // CMP1 output drives FTM4 hardware trigger 2
};
using FTM4TRG2SRC_ = Field<FTM4TRG2SRC_e, Mask<12>{}, RW, struct SOPT6_>;
// FlexTimer 4 Hardware Trigger 2 Source Select
struct FTM4TRG2SRC : FTM4TRG2SRC_ {
    explicit constexpr FTM4TRG2SRC(FTM4TRG2SRC_e value) : FTM4TRG2SRC_(value) {}
    static constexpr FTM4TRG2SRC_ v0{
        FTM4TRG2SRC_e::v0}; // CMP0 output drives FTM4 hardware trigger 2
    static constexpr FTM4TRG2SRC_ v1{
        FTM4TRG2SRC_e::v1}; // CMP1 output drives FTM4 hardware trigger 2
};

enum class FTM5TRG0SRC_e : std::uint8_t
{
    v0 = 0, // CMP0 output drives FTM5 hardware trigger 0
    v1 = 1  // FTM3 channel match drives FTM5 hardware trigger 0
};
using FTM5TRG0SRC_ = Field<FTM5TRG0SRC_e, Mask<13>{}, RW, struct SOPT6_>;
// FlexTimer 5 Hardware Trigger 0 Source Select
struct FTM5TRG0SRC : FTM5TRG0SRC_ {
    explicit constexpr FTM5TRG0SRC(FTM5TRG0SRC_e value) : FTM5TRG0SRC_(value) {}
    static constexpr FTM5TRG0SRC_ v0{
        FTM5TRG0SRC_e::v0}; // CMP0 output drives FTM5 hardware trigger 0
    static constexpr FTM5TRG0SRC_ v1{
        FTM5TRG0SRC_e::v1}; // FTM3 channel match drives FTM5 hardware trigger 0
};

enum class FTM5TRG1SRC_e : std::uint8_t
{
    v0 = 0, // PDB1 output trigger 1 drives FTM5 hardware trigger 1
    v1 = 1  // FTM4 channel match drives FTM5 hardware trigger 1
};
using FTM5TRG1SRC_ = Field<FTM5TRG1SRC_e, Mask<14>{}, RW, struct SOPT6_>;
// FlexTimer 5 Hardware Trigger 1 Source Select
struct FTM5TRG1SRC : FTM5TRG1SRC_ {
    explicit constexpr FTM5TRG1SRC(FTM5TRG1SRC_e value) : FTM5TRG1SRC_(value) {}
    static constexpr FTM5TRG1SRC_ v0{
        FTM5TRG1SRC_e::v0}; // PDB1 output trigger 1 drives FTM5 hardware
                            // trigger 1
    static constexpr FTM5TRG1SRC_ v1{
        FTM5TRG1SRC_e::v1}; // FTM4 channel match drives FTM5 hardware trigger 1
};

enum class FTM5TRG2SRC_e : std::uint8_t
{
    v0 = 0, // CMP0 output drives FTM5 hardware trigger 2
    v1 = 1  // CMP1 output drives FTM5 hardware trigger 2
};
using FTM5TRG2SRC_ = Field<FTM5TRG2SRC_e, Mask<15>{}, RW, struct SOPT6_>;
// FlexTimer 5 Hardware Trigger 2 Source Select
struct FTM5TRG2SRC : FTM5TRG2SRC_ {
    explicit constexpr FTM5TRG2SRC(FTM5TRG2SRC_e value) : FTM5TRG2SRC_(value) {}
    static constexpr FTM5TRG2SRC_ v0{
        FTM5TRG2SRC_e::v0}; // CMP0 output drives FTM5 hardware trigger 2
    static constexpr FTM5TRG2SRC_ v1{
        FTM5TRG2SRC_e::v1}; // CMP1 output drives FTM5 hardware trigger 2
};

enum class FTM4CH0SRC_e : std::uint8_t
{
    v00 = 0, // FTM4_CH0 signal
    v01 = 1, // CMP0 output
    v10 = 2  // CMP1 output
};
using FTM4CH0SRC_ = Field<FTM4CH0SRC_e, Mask<19, 18>{}, RW, struct SOPT6_>;
// FTM4 channel 0 input capture source select
struct FTM4CH0SRC : FTM4CH0SRC_ {
    explicit constexpr FTM4CH0SRC(FTM4CH0SRC_e value) : FTM4CH0SRC_(value) {}
    static constexpr FTM4CH0SRC_ v00{FTM4CH0SRC_e::v00}; // FTM4_CH0 signal
    static constexpr FTM4CH0SRC_ v01{FTM4CH0SRC_e::v01}; // CMP0 output
    static constexpr FTM4CH0SRC_ v10{FTM4CH0SRC_e::v10}; // CMP1 output
};

enum class FTM5CH0SRC_e : std::uint8_t
{
    v00 = 0, // FTM5_CH0 signal
    v01 = 1, // CMP0 output
    v10 = 2  // CMP1 output
};
using FTM5CH0SRC_ = Field<FTM5CH0SRC_e, Mask<21, 20>{}, RW, struct SOPT6_>;
// FTM5 channel 0 input capture source select
struct FTM5CH0SRC : FTM5CH0SRC_ {
    explicit constexpr FTM5CH0SRC(FTM5CH0SRC_e value) : FTM5CH0SRC_(value) {}
    static constexpr FTM5CH0SRC_ v00{FTM5CH0SRC_e::v00}; // FTM5_CH0 signal
    static constexpr FTM5CH0SRC_ v01{FTM5CH0SRC_e::v01}; // CMP0 output
    static constexpr FTM5CH0SRC_ v10{FTM5CH0SRC_e::v10}; // CMP1 output
};

enum class FTM3CLKSEL_e : std::uint8_t
{
    v00 = 0, // FTM3 external clock driven by FTM_CLKIN0 pin
    v01 = 1, // FTM3 external clock driven by FTM_CLKIN1 pin
    v10 = 2  // FTM3 external clock driven by FTM_CLKIN2 pin
};
using FTM3CLKSEL_ = Field<FTM3CLKSEL_e, Mask<25, 24>{}, RW, struct SOPT6_>;
// FTM3 External Clock Pin Select
struct FTM3CLKSEL : FTM3CLKSEL_ {
    explicit constexpr FTM3CLKSEL(FTM3CLKSEL_e value) : FTM3CLKSEL_(value) {}
    static constexpr FTM3CLKSEL_ v00{
        FTM3CLKSEL_e::v00}; // FTM3 external clock driven by FTM_CLKIN0 pin
    static constexpr FTM3CLKSEL_ v01{
        FTM3CLKSEL_e::v01}; // FTM3 external clock driven by FTM_CLKIN1 pin
    static constexpr FTM3CLKSEL_ v10{
        FTM3CLKSEL_e::v10}; // FTM3 external clock driven by FTM_CLKIN2 pin
};

enum class FTM4CLKSEL_e : std::uint8_t
{
    v00 = 0, // FTM4 external clock driven by FTM_CLKIN0 pin
    v01 = 1, // FTM4 external clock driven by FTM_CLKIN1 pin
    v10 = 2  // FTM4 external clock driven by FTM_CLKIN2 pin
};
using FTM4CLKSEL_ = Field<FTM4CLKSEL_e, Mask<27, 26>{}, RW, struct SOPT6_>;
// FTM4 External Clock Pin Select
struct FTM4CLKSEL : FTM4CLKSEL_ {
    explicit constexpr FTM4CLKSEL(FTM4CLKSEL_e value) : FTM4CLKSEL_(value) {}
    static constexpr FTM4CLKSEL_ v00{
        FTM4CLKSEL_e::v00}; // FTM4 external clock driven by FTM_CLKIN0 pin
    static constexpr FTM4CLKSEL_ v01{
        FTM4CLKSEL_e::v01}; // FTM4 external clock driven by FTM_CLKIN1 pin
    static constexpr FTM4CLKSEL_ v10{
        FTM4CLKSEL_e::v10}; // FTM4 external clock driven by FTM_CLKIN2 pin
};

enum class FTM5CLKSEL_e : std::uint8_t
{
    v00 = 0, // FTM5 external clock driven by FTM_CLKIN0 pin
    v01 = 1, // FTM5 external clock driven by FTM_CLKIN1 pin
    v10 = 2  // FTM5 external clock driven by FTM_CLKIN2 pin
};
using FTM5CLKSEL_ = Field<FTM5CLKSEL_e, Mask<29, 28>{}, RW, struct SOPT6_>;
// FTM5 External Clock Pin Select
struct FTM5CLKSEL : FTM5CLKSEL_ {
    explicit constexpr FTM5CLKSEL(FTM5CLKSEL_e value) : FTM5CLKSEL_(value) {}
    static constexpr FTM5CLKSEL_ v00{
        FTM5CLKSEL_e::v00}; // FTM5 external clock driven by FTM_CLKIN0 pin
    static constexpr FTM5CLKSEL_ v01{
        FTM5CLKSEL_e::v01}; // FTM5 external clock driven by FTM_CLKIN1 pin
    static constexpr FTM5CLKSEL_ v10{
        FTM5CLKSEL_e::v10}; // FTM5 external clock driven by FTM_CLKIN2 pin
};
using reg =
    Register<std::uint32_t, 0x0, FTM3FLT0_, FTM4FLT0_, FTM5FLT0_, FTM3TRG0SRC_,
             FTM3TRG1SRC_, FTM3TRG2SRC_, FTM4TRG0SRC_, FTM4TRG1SRC_,
             FTM4TRG2SRC_, FTM5TRG0SRC_, FTM5TRG1SRC_, FTM5TRG2SRC_,
             FTM4CH0SRC_, FTM5CH0SRC_, FTM3CLKSEL_, FTM4CLKSEL_, FTM5CLKSEL_>;
} // namespace SOPT6_


inline namespace SOPT7_ {

enum class ADC0TRGSEL_e : std::uint8_t
{
    PDB_EXTRG0 = 0, // External trigger pin input (PDB_EXTRG0)
    CMP0 = 1,       // CMP0 output
    CMP1 = 2,       // CMP1 output
    PDB_EXTRG1 = 3, // External trigger pin input (PDB_EXTRG1)
    v0100 = 4,      // DMA channel 0 transfer last write complete
    v0101 = 5,      // DMA channel 1 transfer last write complete
    v0110 = 6,      // DMA channel 2 transfer last write complete
    v0111 = 7,      // DMA channel 3 transfer last write complete
    v1000 = 8,      // FTM0 intialtrig or external trig output
    v1001 = 9,      // FTM1 intial trig or external trig output
    v1010 = 10,     // FTM2 intial trig or external trig output
    v1011 = 11,     // FTM3 intial trig or external trig output
    v1100 = 12,     // FTM4 intial trig or external trig output
    v1101 = 13,     // FTM5 intial trig or external trig output
    LPTMR0 = 14     // LPTMR0 trigger
};
using ADC0TRGSEL_ = Field<ADC0TRGSEL_e, Mask<3, 0>{}, RW, struct SOPT7_>;
// ADC0 Trigger Select
struct ADC0TRGSEL : ADC0TRGSEL_ {
    explicit constexpr ADC0TRGSEL(ADC0TRGSEL_e value) : ADC0TRGSEL_(value) {}
    static constexpr ADC0TRGSEL_ PDB_EXTRG0{
        ADC0TRGSEL_e::PDB_EXTRG0}; // External trigger pin input (PDB_EXTRG0)
    static constexpr ADC0TRGSEL_ CMP0{ADC0TRGSEL_e::CMP0}; // CMP0 output
    static constexpr ADC0TRGSEL_ CMP1{ADC0TRGSEL_e::CMP1}; // CMP1 output
    static constexpr ADC0TRGSEL_ PDB_EXTRG1{
        ADC0TRGSEL_e::PDB_EXTRG1}; // External trigger pin input (PDB_EXTRG1)
    static constexpr ADC0TRGSEL_ v0100{
        ADC0TRGSEL_e::v0100}; // DMA channel 0 transfer last write complete
    static constexpr ADC0TRGSEL_ v0101{
        ADC0TRGSEL_e::v0101}; // DMA channel 1 transfer last write complete
    static constexpr ADC0TRGSEL_ v0110{
        ADC0TRGSEL_e::v0110}; // DMA channel 2 transfer last write complete
    static constexpr ADC0TRGSEL_ v0111{
        ADC0TRGSEL_e::v0111}; // DMA channel 3 transfer last write complete
    static constexpr ADC0TRGSEL_ v1000{
        ADC0TRGSEL_e::v1000}; // FTM0 intialtrig or external trig output
    static constexpr ADC0TRGSEL_ v1001{
        ADC0TRGSEL_e::v1001}; // FTM1 intial trig or external trig output
    static constexpr ADC0TRGSEL_ v1010{
        ADC0TRGSEL_e::v1010}; // FTM2 intial trig or external trig output
    static constexpr ADC0TRGSEL_ v1011{
        ADC0TRGSEL_e::v1011}; // FTM3 intial trig or external trig output
    static constexpr ADC0TRGSEL_ v1100{
        ADC0TRGSEL_e::v1100}; // FTM4 intial trig or external trig output
    static constexpr ADC0TRGSEL_ v1101{
        ADC0TRGSEL_e::v1101}; // FTM5 intial trig or external trig output
    static constexpr ADC0TRGSEL_ LPTMR0{ADC0TRGSEL_e::LPTMR0}; // LPTMR0 trigger
};

enum class ADC0PRETRGSEL_e : std::uint8_t
{
    v0 = 0, // Pre-trigger A for ADC0. Clearing this field will result in
            // ADHWTSA=1 and ADHWTSB=0.
    v1 = 1  // Pre-trigger B for ADC0. Setting this bit will result in ADHWTSA=0
            // and ADHWTSB=1.
};
using ADC0PRETRGSEL_ = Field<ADC0PRETRGSEL_e, Mask<4>{}, RW, struct SOPT7_>;
// ADC0 Pre-trigger Select
struct ADC0PRETRGSEL : ADC0PRETRGSEL_ {
    explicit constexpr ADC0PRETRGSEL(ADC0PRETRGSEL_e value)
        : ADC0PRETRGSEL_(value)
    {}
    static constexpr ADC0PRETRGSEL_ v0{
        ADC0PRETRGSEL_e::v0}; // Pre-trigger A for ADC0. Clearing this field
                              // will result in ADHWTSA=1 and ADHWTSB=0.
    static constexpr ADC0PRETRGSEL_ v1{
        ADC0PRETRGSEL_e::v1}; // Pre-trigger B for ADC0. Setting this bit will
                              // result in ADHWTSA=0 and ADHWTSB=1.
};

enum class ADC0ALTTRGEN_e : std::uint8_t
{
    v00 = 0, // PDB0 CH0 triggers ADC0
    v01 = 1, // PDB1 CH0 triggers ADC0
    v10 = 2, // Alt trigger source as per ADC0TRGSEL
    v11 = 3  // PDB0 CH0 OR PDB1 CH0 trigger ADC0
};
using ADC0ALTTRGEN_ = Field<ADC0ALTTRGEN_e, Mask<7, 6>{}, RW, struct SOPT7_>;
// Enable alternative conversion triggers for ADC0.
struct ADC0ALTTRGEN : ADC0ALTTRGEN_ {
    explicit constexpr ADC0ALTTRGEN(ADC0ALTTRGEN_e value) : ADC0ALTTRGEN_(value)
    {}
    static constexpr ADC0ALTTRGEN_ v00{
        ADC0ALTTRGEN_e::v00}; // PDB0 CH0 triggers ADC0
    static constexpr ADC0ALTTRGEN_ v01{
        ADC0ALTTRGEN_e::v01}; // PDB1 CH0 triggers ADC0
    static constexpr ADC0ALTTRGEN_ v10{
        ADC0ALTTRGEN_e::v10}; // Alt trigger source as per ADC0TRGSEL
    static constexpr ADC0ALTTRGEN_ v11{
        ADC0ALTTRGEN_e::v11}; // PDB0 CH0 OR PDB1 CH0 trigger ADC0
};

enum class ADC1TRGSEL_e : std::uint8_t
{
    v0000 = 0,  // External trigger pin input (PDB_EXTRG0)
    v0001 = 1,  // CMP0 output
    v0010 = 2,  // CMP1 output
    v0011 = 3,  // External trigger pin input (PDB_EXTRG1)
    v0100 = 4,  // DMA channel 0 transfer last write complete
    v0101 = 5,  // DMA channel 1 transfer last write complete
    v0110 = 6,  // DMA channel 2 transfer last write complete
    v0111 = 7,  // DMA channel 3 transfer last write complete
    v1000 = 8,  // FTM0 intialtrig or external trig output
    v1001 = 9,  // FTM1 intial trig or external trig output
    v1010 = 10, // FTM2 intial trig or external trig output
    v1011 = 11, // FTM3 intial trig or external trig output
    v1100 = 12, // FTM4 intial trig or external trig output
    v1101 = 13, // FTM5 intial trig or external trig output
    v1110 = 14  // LPTMR0 trigger
};
using ADC1TRGSEL_ = Field<ADC1TRGSEL_e, Mask<11, 8>{}, RW, struct SOPT7_>;
// ADC1 Trigger Select
struct ADC1TRGSEL : ADC1TRGSEL_ {
    explicit constexpr ADC1TRGSEL(ADC1TRGSEL_e value) : ADC1TRGSEL_(value) {}
    static constexpr ADC1TRGSEL_ v0000{
        ADC1TRGSEL_e::v0000}; // External trigger pin input (PDB_EXTRG0)
    static constexpr ADC1TRGSEL_ v0001{ADC1TRGSEL_e::v0001}; // CMP0 output
    static constexpr ADC1TRGSEL_ v0010{ADC1TRGSEL_e::v0010}; // CMP1 output
    static constexpr ADC1TRGSEL_ v0011{
        ADC1TRGSEL_e::v0011}; // External trigger pin input (PDB_EXTRG1)
    static constexpr ADC1TRGSEL_ v0100{
        ADC1TRGSEL_e::v0100}; // DMA channel 0 transfer last write complete
    static constexpr ADC1TRGSEL_ v0101{
        ADC1TRGSEL_e::v0101}; // DMA channel 1 transfer last write complete
    static constexpr ADC1TRGSEL_ v0110{
        ADC1TRGSEL_e::v0110}; // DMA channel 2 transfer last write complete
    static constexpr ADC1TRGSEL_ v0111{
        ADC1TRGSEL_e::v0111}; // DMA channel 3 transfer last write complete
    static constexpr ADC1TRGSEL_ v1000{
        ADC1TRGSEL_e::v1000}; // FTM0 intialtrig or external trig output
    static constexpr ADC1TRGSEL_ v1001{
        ADC1TRGSEL_e::v1001}; // FTM1 intial trig or external trig output
    static constexpr ADC1TRGSEL_ v1010{
        ADC1TRGSEL_e::v1010}; // FTM2 intial trig or external trig output
    static constexpr ADC1TRGSEL_ v1011{
        ADC1TRGSEL_e::v1011}; // FTM3 intial trig or external trig output
    static constexpr ADC1TRGSEL_ v1100{
        ADC1TRGSEL_e::v1100}; // FTM4 intial trig or external trig output
    static constexpr ADC1TRGSEL_ v1101{
        ADC1TRGSEL_e::v1101}; // FTM5 intial trig or external trig output
    static constexpr ADC1TRGSEL_ v1110{ADC1TRGSEL_e::v1110}; // LPTMR0 trigger
};

enum class ADC1PRETRGSEL_e : std::uint8_t
{
    v0 = 0, // Pre-trigger A for ADC1. Clearing this field will result in
            // ADHWTSA=1 and ADHWTSB=0.
    v1 = 1  // Pre-trigger B for ADC1. Setting this bit will result in ADHWTSA=0
            // and ADHWTSB=1.
};
using ADC1PRETRGSEL_ = Field<ADC1PRETRGSEL_e, Mask<12>{}, RW, struct SOPT7_>;
// ADC1 Pre-trigger Select
struct ADC1PRETRGSEL : ADC1PRETRGSEL_ {
    explicit constexpr ADC1PRETRGSEL(ADC1PRETRGSEL_e value)
        : ADC1PRETRGSEL_(value)
    {}
    static constexpr ADC1PRETRGSEL_ v0{
        ADC1PRETRGSEL_e::v0}; // Pre-trigger A for ADC1. Clearing this field
                              // will result in ADHWTSA=1 and ADHWTSB=0.
    static constexpr ADC1PRETRGSEL_ v1{
        ADC1PRETRGSEL_e::v1}; // Pre-trigger B for ADC1. Setting this bit will
                              // result in ADHWTSA=0 and ADHWTSB=1.
};

enum class ADC1ALTTRGEN_e : std::uint8_t
{
    v00 = 0, // PDB0 CH1 triggers ADC1
    v01 = 1, // PDB1 CH1 triggers ADC1
    v10 = 2, // Alt trigger source ADC1TRGSEL
    v11 = 3  // PDB0 CH1 OR PDB1 CH1 trigger ADC1
};
using ADC1ALTTRGEN_ = Field<ADC1ALTTRGEN_e, Mask<15, 14>{}, RW, struct SOPT7_>;
// Enable alternative conversion triggers for ADC1.
struct ADC1ALTTRGEN : ADC1ALTTRGEN_ {
    explicit constexpr ADC1ALTTRGEN(ADC1ALTTRGEN_e value) : ADC1ALTTRGEN_(value)
    {}
    static constexpr ADC1ALTTRGEN_ v00{
        ADC1ALTTRGEN_e::v00}; // PDB0 CH1 triggers ADC1
    static constexpr ADC1ALTTRGEN_ v01{
        ADC1ALTTRGEN_e::v01}; // PDB1 CH1 triggers ADC1
    static constexpr ADC1ALTTRGEN_ v10{
        ADC1ALTTRGEN_e::v10}; // Alt trigger source ADC1TRGSEL
    static constexpr ADC1ALTTRGEN_ v11{
        ADC1ALTTRGEN_e::v11}; // PDB0 CH1 OR PDB1 CH1 trigger ADC1
};

enum class ADC0ALTCLKSRC_e : std::uint8_t
{
    v00 = 0, // OUTDIV5 output
    v01 = 1, // MCGIRCLK
    v10 = 2  // OSCERCLK
};
using ADC0ALTCLKSRC_ =
    Field<ADC0ALTCLKSRC_e, Mask<25, 24>{}, RW, struct SOPT7_>;
// ADC0 ALT Clock Source Select
struct ADC0ALTCLKSRC : ADC0ALTCLKSRC_ {
    explicit constexpr ADC0ALTCLKSRC(ADC0ALTCLKSRC_e value)
        : ADC0ALTCLKSRC_(value)
    {}
    static constexpr ADC0ALTCLKSRC_ v00{ADC0ALTCLKSRC_e::v00}; // OUTDIV5 output
    static constexpr ADC0ALTCLKSRC_ v01{ADC0ALTCLKSRC_e::v01}; // MCGIRCLK
    static constexpr ADC0ALTCLKSRC_ v10{ADC0ALTCLKSRC_e::v10}; // OSCERCLK
};

enum class ADC1ALTCLKSRC_e : std::uint8_t
{
    v00 = 0, // OUTDIV5 output
    v01 = 1, // MCGIRCLK
    v10 = 2  // OSCERCLK
};
using ADC1ALTCLKSRC_ =
    Field<ADC1ALTCLKSRC_e, Mask<27, 26>{}, RW, struct SOPT7_>;
// ADC1 ALT Clock Source Select
struct ADC1ALTCLKSRC : ADC1ALTCLKSRC_ {
    explicit constexpr ADC1ALTCLKSRC(ADC1ALTCLKSRC_e value)
        : ADC1ALTCLKSRC_(value)
    {}
    static constexpr ADC1ALTCLKSRC_ v00{ADC1ALTCLKSRC_e::v00}; // OUTDIV5 output
    static constexpr ADC1ALTCLKSRC_ v01{ADC1ALTCLKSRC_e::v01}; // MCGIRCLK
    static constexpr ADC1ALTCLKSRC_ v10{ADC1ALTCLKSRC_e::v10}; // OSCERCLK
};
using reg = Register<std::uint32_t, 0x0, ADC0TRGSEL_, ADC0PRETRGSEL_,
                     ADC0ALTTRGEN_, ADC1TRGSEL_, ADC1PRETRGSEL_, ADC1ALTTRGEN_,
                     ADC0ALTCLKSRC_, ADC1ALTCLKSRC_>;
} // namespace SOPT7_


inline namespace SOPT8_ {

enum class FTM0SYNCBIT_e : std::uint8_t
{
    v0 = 0, // No effect to FTM0; this allow the hardware trigger options to
            // function as expected. See SOPT4[FTM0TRG0SRC].
    v1 = 1  // If TRIG0 enabled, this refreshes the FTM0CNTIN and all buffered
            // registers of the FTM0 (must write 0 first then write 1); this
            // masks the hardware trigger.
};
using FTM0SYNCBIT_ = Field<FTM0SYNCBIT_e, Mask<0>{}, RW, struct SOPT8_>;
// FlexTimer 0 Hardware Trigger 0 configure by software
struct FTM0SYNCBIT : FTM0SYNCBIT_ {
    explicit constexpr FTM0SYNCBIT(FTM0SYNCBIT_e value) : FTM0SYNCBIT_(value) {}
    static constexpr FTM0SYNCBIT_ v0{
        FTM0SYNCBIT_e::v0}; // No effect to FTM0; this allow the hardware
                            // trigger options to function as expected. See
                            // SOPT4[FTM0TRG0SRC].
    static constexpr FTM0SYNCBIT_ v1{
        FTM0SYNCBIT_e::v1}; // If TRIG0 enabled, this refreshes the FTM0CNTIN
                            // and all buffered registers of the FTM0 (must
                            // write 0 first then write 1); this masks the
                            // hardware trigger.
};

enum class FTM1SYNCBIT_e : std::uint8_t
{
    v0 = 0, // No effect to FTM1; this allows the hardware trigger options to
            // function as expected. See SOPT4[FTM1TRG0SRC].
    v1 = 1  // If TRIG0 enabled, this refreshes the FTM1CNTIN and all buffered
            // registers of the FTM1 (must write 0 first then write 1); this
            // masks the hardware trigger.
};
using FTM1SYNCBIT_ = Field<FTM1SYNCBIT_e, Mask<1>{}, RW, struct SOPT8_>;
// FlexTimer 1 Hardware Trigger 0 configure by software
struct FTM1SYNCBIT : FTM1SYNCBIT_ {
    explicit constexpr FTM1SYNCBIT(FTM1SYNCBIT_e value) : FTM1SYNCBIT_(value) {}
    static constexpr FTM1SYNCBIT_ v0{
        FTM1SYNCBIT_e::v0}; // No effect to FTM1; this allows the hardware
                            // trigger options to function as expected. See
                            // SOPT4[FTM1TRG0SRC].
    static constexpr FTM1SYNCBIT_ v1{
        FTM1SYNCBIT_e::v1}; // If TRIG0 enabled, this refreshes the FTM1CNTIN
                            // and all buffered registers of the FTM1 (must
                            // write 0 first then write 1); this masks the
                            // hardware trigger.
};

enum class FTM2SYNCBIT_e : std::uint8_t
{
    v0 = 0, // No effect to FTM2; this allows the hardware trigger options to
            // function as expected. See SOPT4[FTM2TRG0SRC].
    v1 = 1 // If TRIG0 is enabled, this refreshes the FTM2CNTIN and all buffered
           // registers of the FTM2 (must write 0 first then write 1); this
           // masks the hardware trigger.
};
using FTM2SYNCBIT_ = Field<FTM2SYNCBIT_e, Mask<2>{}, RW, struct SOPT8_>;
// FlexTimer 2 Hardware Trigger 0 configure by software
struct FTM2SYNCBIT : FTM2SYNCBIT_ {
    explicit constexpr FTM2SYNCBIT(FTM2SYNCBIT_e value) : FTM2SYNCBIT_(value) {}
    static constexpr FTM2SYNCBIT_ v0{
        FTM2SYNCBIT_e::v0}; // No effect to FTM2; this allows the hardware
                            // trigger options to function as expected. See
                            // SOPT4[FTM2TRG0SRC].
    static constexpr FTM2SYNCBIT_ v1{
        FTM2SYNCBIT_e::v1}; // If TRIG0 is enabled, this refreshes the FTM2CNTIN
                            // and all buffered registers of the FTM2 (must
                            // write 0 first then write 1); this masks the
                            // hardware trigger.
};

enum class FTM3SYNCBIT_e : std::uint8_t
{
    v0 = 0, // No effect to FTM3; this allows the hardware trigger options to
            // function as expected. See SOPT6[FTM3TRG0SRC].
    v1 = 1  // If TRIG0 is enabled, this refreshes the FTM3CNTIN and allbuffered
            // registers of the FTM3 (must write 0 first then write 1); this
            // masks the hardware trigger.
};
using FTM3SYNCBIT_ = Field<FTM3SYNCBIT_e, Mask<3>{}, RW, struct SOPT8_>;
// FlexTimer 3 Hardware Trigger 0 configure by software
struct FTM3SYNCBIT : FTM3SYNCBIT_ {
    explicit constexpr FTM3SYNCBIT(FTM3SYNCBIT_e value) : FTM3SYNCBIT_(value) {}
    static constexpr FTM3SYNCBIT_ v0{
        FTM3SYNCBIT_e::v0}; // No effect to FTM3; this allows the hardware
                            // trigger options to function as expected. See
                            // SOPT6[FTM3TRG0SRC].
    static constexpr FTM3SYNCBIT_ v1{
        FTM3SYNCBIT_e::v1}; // If TRIG0 is enabled, this refreshes the FTM3CNTIN
                            // and allbuffered registers of the FTM3 (must write
                            // 0 first then write 1); this masks the hardware
                            // trigger.
};

enum class FTM4SYNCBIT_e : std::uint8_t
{
    v0 = 0, // No effect to FTM4; this allows the hardware trigger options to
            // function as expected. See SOPT6[FTM4TRG0SRC].
    v1 = 1  // If TRIG0 is enabled, this refreshes the FTM4CNTIN and allbuffered
            // registers of the FTM4 (must write 0 first then write 1); this
            // masks the hardware trigger.
};
using FTM4SYNCBIT_ = Field<FTM4SYNCBIT_e, Mask<4>{}, RW, struct SOPT8_>;
// FlexTimer 4 Hardware Trigger 0 configure by software
struct FTM4SYNCBIT : FTM4SYNCBIT_ {
    explicit constexpr FTM4SYNCBIT(FTM4SYNCBIT_e value) : FTM4SYNCBIT_(value) {}
    static constexpr FTM4SYNCBIT_ v0{
        FTM4SYNCBIT_e::v0}; // No effect to FTM4; this allows the hardware
                            // trigger options to function as expected. See
                            // SOPT6[FTM4TRG0SRC].
    static constexpr FTM4SYNCBIT_ v1{
        FTM4SYNCBIT_e::v1}; // If TRIG0 is enabled, this refreshes the FTM4CNTIN
                            // and allbuffered registers of the FTM4 (must write
                            // 0 first then write 1); this masks the hardware
                            // trigger.
};

enum class FTM5SYNCBIT_e : std::uint8_t
{
    v0 = 0, // No effect on FTM5; this allows the hardware trigger options to
            // function as expected. See SOPT6[FTM5TRG0SRC].
    v1 = 1  // If TRIG0 is enabled, this refreshes the FTM5CNTIN and allbuffered
            // registers of the FTM5 (must write 0 first then write 1); this
            // masks the hardware trigger.
};
using FTM5SYNCBIT_ = Field<FTM5SYNCBIT_e, Mask<5>{}, RW, struct SOPT8_>;
// FlexTimer 5 Hardware Trigger 0 configure by software
struct FTM5SYNCBIT : FTM5SYNCBIT_ {
    explicit constexpr FTM5SYNCBIT(FTM5SYNCBIT_e value) : FTM5SYNCBIT_(value) {}
    static constexpr FTM5SYNCBIT_ v0{
        FTM5SYNCBIT_e::v0}; // No effect on FTM5; this allows the hardware
                            // trigger options to function as expected. See
                            // SOPT6[FTM5TRG0SRC].
    static constexpr FTM5SYNCBIT_ v1{
        FTM5SYNCBIT_e::v1}; // If TRIG0 is enabled, this refreshes the FTM5CNTIN
                            // and allbuffered registers of the FTM5 (must write
                            // 0 first then write 1); this masks the hardware
                            // trigger.
};

enum class CARRIER_SELECT0_e : std::uint8_t
{
    v00 = 0, // FTM1_CH1 output provides the carrier signal for Timer Modulation
             // mode
    v01 = 1, // LPTMR0 prescaler output provides the carrier signal for Timer
             // Modulation mode
    v10 = 2  // FTM5_CH1 output provides the carrier signal for Timer Modulation
             // mode
};
using CARRIER_SELECT0_ =
    Field<CARRIER_SELECT0_e, Mask<9, 8>{}, RW, struct SOPT8_>;
// Carrier frequency selection for FTM0/2 output channel
struct CARRIER_SELECT0 : CARRIER_SELECT0_ {
    explicit constexpr CARRIER_SELECT0(CARRIER_SELECT0_e value)
        : CARRIER_SELECT0_(value)
    {}
    static constexpr CARRIER_SELECT0_ v00{
        CARRIER_SELECT0_e::v00}; // FTM1_CH1 output provides the carrier signal
                                 // for Timer Modulation mode
    static constexpr CARRIER_SELECT0_ v01{
        CARRIER_SELECT0_e::v01}; // LPTMR0 prescaler output provides the carrier
                                 // signal for Timer Modulation mode
    static constexpr CARRIER_SELECT0_ v10{
        CARRIER_SELECT0_e::v10}; // FTM5_CH1 output provides the carrier signal
                                 // for Timer Modulation mode
};

enum class FTM0OCH0SRC_e : std::uint8_t
{
    v0 = 0, // FTM0CH0 pin is the output of FTM0 channel 0 PWM/OCMP
    v1 = 1  // FTM0CH0 pin is the output of FTM0 channel 0 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM0OCH0SRC_ = Field<FTM0OCH0SRC_e, Mask<16>{}, RW, struct SOPT8_>;
// FTM0 channel 0 output PWM/OCMP mode source select
struct FTM0OCH0SRC : FTM0OCH0SRC_ {
    explicit constexpr FTM0OCH0SRC(FTM0OCH0SRC_e value) : FTM0OCH0SRC_(value) {}
    static constexpr FTM0OCH0SRC_ v0{
        FTM0OCH0SRC_e::v0}; // FTM0CH0 pin is the output of FTM0 channel 0
                            // PWM/OCMP
    static constexpr FTM0OCH0SRC_ v1{
        FTM0OCH0SRC_e::v1}; // FTM0CH0 pin is the output of FTM0 channel 0
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM0OCH1SRC_e : std::uint8_t
{
    v0 = 0, // FTM0CH1 pin is the output of FTM0 channel 1 PWM/OCMP
    v1 = 1  // FTM0CH1 pin is the output of FTM0 channel 1 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM0OCH1SRC_ = Field<FTM0OCH1SRC_e, Mask<17>{}, RW, struct SOPT8_>;
// FTM0 channel 1 output PWM/OCMP mode source select
struct FTM0OCH1SRC : FTM0OCH1SRC_ {
    explicit constexpr FTM0OCH1SRC(FTM0OCH1SRC_e value) : FTM0OCH1SRC_(value) {}
    static constexpr FTM0OCH1SRC_ v0{
        FTM0OCH1SRC_e::v0}; // FTM0CH1 pin is the output of FTM0 channel 1
                            // PWM/OCMP
    static constexpr FTM0OCH1SRC_ v1{
        FTM0OCH1SRC_e::v1}; // FTM0CH1 pin is the output of FTM0 channel 1
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM0OCH2SRC_e : std::uint8_t
{
    v0 = 0, // FTM0CH2 pin is the output of FTM0 channel 2 PWM/OCMP
    v1 = 1  // FTM0CH2 pin is the output of FTM0 channel 2 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM0OCH2SRC_ = Field<FTM0OCH2SRC_e, Mask<18>{}, RW, struct SOPT8_>;
// FTM0 channel 2 output PWM/OCMP mode source select
struct FTM0OCH2SRC : FTM0OCH2SRC_ {
    explicit constexpr FTM0OCH2SRC(FTM0OCH2SRC_e value) : FTM0OCH2SRC_(value) {}
    static constexpr FTM0OCH2SRC_ v0{
        FTM0OCH2SRC_e::v0}; // FTM0CH2 pin is the output of FTM0 channel 2
                            // PWM/OCMP
    static constexpr FTM0OCH2SRC_ v1{
        FTM0OCH2SRC_e::v1}; // FTM0CH2 pin is the output of FTM0 channel 2
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM0OCH3SRC_e : std::uint8_t
{
    v0 = 0, // FTM0CH3 pin is the output of FTM0 channel 3 PWM/OCMP
    v1 = 1  // FTM0CH3 pin is the output of FTM0 channel 3 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM0OCH3SRC_ = Field<FTM0OCH3SRC_e, Mask<19>{}, RW, struct SOPT8_>;
// FTM0 channel 3 output PWM/OCMP mode source select
struct FTM0OCH3SRC : FTM0OCH3SRC_ {
    explicit constexpr FTM0OCH3SRC(FTM0OCH3SRC_e value) : FTM0OCH3SRC_(value) {}
    static constexpr FTM0OCH3SRC_ v0{
        FTM0OCH3SRC_e::v0}; // FTM0CH3 pin is the output of FTM0 channel 3
                            // PWM/OCMP
    static constexpr FTM0OCH3SRC_ v1{
        FTM0OCH3SRC_e::v1}; // FTM0CH3 pin is the output of FTM0 channel 3
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM0OCH4SRC_e : std::uint8_t
{
    v0 = 0, // FTM0CH4 pin is the output of FTM0 channel 4 PWM/OCMP
    v1 = 1  // FTM0CH4 pin is the output of FTM0 channel 4 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM0OCH4SRC_ = Field<FTM0OCH4SRC_e, Mask<20>{}, RW, struct SOPT8_>;
// FTM0 channel 4 output PWM/OCMP mode source select
struct FTM0OCH4SRC : FTM0OCH4SRC_ {
    explicit constexpr FTM0OCH4SRC(FTM0OCH4SRC_e value) : FTM0OCH4SRC_(value) {}
    static constexpr FTM0OCH4SRC_ v0{
        FTM0OCH4SRC_e::v0}; // FTM0CH4 pin is the output of FTM0 channel 4
                            // PWM/OCMP
    static constexpr FTM0OCH4SRC_ v1{
        FTM0OCH4SRC_e::v1}; // FTM0CH4 pin is the output of FTM0 channel 4
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM0OCH5SRC_e : std::uint8_t
{
    v0 = 0, // FTM0CH5 pin is the output of FTM0 channel 5 PWM/OCMP
    v1 = 1  // FTM0CH5 pin is the output of FTM0 channel 5 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM0OCH5SRC_ = Field<FTM0OCH5SRC_e, Mask<21>{}, RW, struct SOPT8_>;
// FTM0 channel 5 output PWM/OCMP mode source select
struct FTM0OCH5SRC : FTM0OCH5SRC_ {
    explicit constexpr FTM0OCH5SRC(FTM0OCH5SRC_e value) : FTM0OCH5SRC_(value) {}
    static constexpr FTM0OCH5SRC_ v0{
        FTM0OCH5SRC_e::v0}; // FTM0CH5 pin is the output of FTM0 channel 5
                            // PWM/OCMP
    static constexpr FTM0OCH5SRC_ v1{
        FTM0OCH5SRC_e::v1}; // FTM0CH5 pin is the output of FTM0 channel 5
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM2OCH0SRC_e : std::uint8_t
{
    v0 = 0, // FTM2CH0 pin is the output of FTM2 channel 0 PWM/OCMP
    v1 = 1  // FTM2CH0 pin is the output of FTM2 channel 0 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM2OCH0SRC_ = Field<FTM2OCH0SRC_e, Mask<22>{}, RW, struct SOPT8_>;
// FTM2 channel 0 output PWM/OCMP mode source select
struct FTM2OCH0SRC : FTM2OCH0SRC_ {
    explicit constexpr FTM2OCH0SRC(FTM2OCH0SRC_e value) : FTM2OCH0SRC_(value) {}
    static constexpr FTM2OCH0SRC_ v0{
        FTM2OCH0SRC_e::v0}; // FTM2CH0 pin is the output of FTM2 channel 0
                            // PWM/OCMP
    static constexpr FTM2OCH0SRC_ v1{
        FTM2OCH0SRC_e::v1}; // FTM2CH0 pin is the output of FTM2 channel 0
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};

enum class FTM2OCH1SRC_e : std::uint8_t
{
    v0 = 0, // FTM2CH1 pin is the output of FTM2 channel 1 PWM/OCMP
    v1 = 1  // FTM2CH1 pin is the output of FTM2 channel 1 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT0
};
using FTM2OCH1SRC_ = Field<FTM2OCH1SRC_e, Mask<23>{}, RW, struct SOPT8_>;
// FTM2 channel 1 output PWM/OCMP mode source select
struct FTM2OCH1SRC : FTM2OCH1SRC_ {
    explicit constexpr FTM2OCH1SRC(FTM2OCH1SRC_e value) : FTM2OCH1SRC_(value) {}
    static constexpr FTM2OCH1SRC_ v0{
        FTM2OCH1SRC_e::v0}; // FTM2CH1 pin is the output of FTM2 channel 1
                            // PWM/OCMP
    static constexpr FTM2OCH1SRC_ v1{
        FTM2OCH1SRC_e::v1}; // FTM2CH1 pin is the output of FTM2 channel 1
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT0
};
using reg =
    Register<std::uint32_t, 0x0, FTM0SYNCBIT_, FTM1SYNCBIT_, FTM2SYNCBIT_,
             FTM3SYNCBIT_, FTM4SYNCBIT_, FTM5SYNCBIT_, CARRIER_SELECT0_,
             FTM0OCH0SRC_, FTM0OCH1SRC_, FTM0OCH2SRC_, FTM0OCH3SRC_,
             FTM0OCH4SRC_, FTM0OCH5SRC_, FTM2OCH0SRC_, FTM2OCH1SRC_>;
} // namespace SOPT8_


inline namespace SOPT9_ {

enum class CARRIER_SELECT1_e : std::uint8_t
{
    v00 = 0, // FTM1_CH1 output provides the carrier signal for Timer Modulation
             // mode
    v01 = 1, // LPTMR0 prescaler output provides the carrier signal for Timer
             // Modulation mode
    v10 = 2  // FTM5_CH1 output provides the carrier signal for Timer Modulation
             // mode
};
using CARRIER_SELECT1_ =
    Field<CARRIER_SELECT1_e, Mask<9, 8>{}, RW, struct SOPT9_>;
// Carrier frequency selection for FTM3/4 output channel
struct CARRIER_SELECT1 : CARRIER_SELECT1_ {
    explicit constexpr CARRIER_SELECT1(CARRIER_SELECT1_e value)
        : CARRIER_SELECT1_(value)
    {}
    static constexpr CARRIER_SELECT1_ v00{
        CARRIER_SELECT1_e::v00}; // FTM1_CH1 output provides the carrier signal
                                 // for Timer Modulation mode
    static constexpr CARRIER_SELECT1_ v01{
        CARRIER_SELECT1_e::v01}; // LPTMR0 prescaler output provides the carrier
                                 // signal for Timer Modulation mode
    static constexpr CARRIER_SELECT1_ v10{
        CARRIER_SELECT1_e::v10}; // FTM5_CH1 output provides the carrier signal
                                 // for Timer Modulation mode
};

enum class FTM3OCH0SRC_e : std::uint8_t
{
    v0 = 0, // FTM3CH0 pin is the output of FTM3 channel 0 PWM/OCMP
    v1 = 1  // FTM3CH0 pin is the output of FTM3 channel 0 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM3OCH0SRC_ = Field<FTM3OCH0SRC_e, Mask<16>{}, RW, struct SOPT9_>;
// FTM3 channel 0 output PWM/OCMP mode source select
struct FTM3OCH0SRC : FTM3OCH0SRC_ {
    explicit constexpr FTM3OCH0SRC(FTM3OCH0SRC_e value) : FTM3OCH0SRC_(value) {}
    static constexpr FTM3OCH0SRC_ v0{
        FTM3OCH0SRC_e::v0}; // FTM3CH0 pin is the output of FTM3 channel 0
                            // PWM/OCMP
    static constexpr FTM3OCH0SRC_ v1{
        FTM3OCH0SRC_e::v1}; // FTM3CH0 pin is the output of FTM3 channel 0
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM3OCH1SRC_e : std::uint8_t
{
    v0 = 0, // FTM3CH1 pin is the output of FTM3 channel 1 PWM/OCMP
    v1 = 1  // FTM3CH1 pin is the output of FTM3 channel 1 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM3OCH1SRC_ = Field<FTM3OCH1SRC_e, Mask<17>{}, RW, struct SOPT9_>;
// FTM3 channel 1 output PWM/OCMP mode source select
struct FTM3OCH1SRC : FTM3OCH1SRC_ {
    explicit constexpr FTM3OCH1SRC(FTM3OCH1SRC_e value) : FTM3OCH1SRC_(value) {}
    static constexpr FTM3OCH1SRC_ v0{
        FTM3OCH1SRC_e::v0}; // FTM3CH1 pin is the output of FTM3 channel 1
                            // PWM/OCMP
    static constexpr FTM3OCH1SRC_ v1{
        FTM3OCH1SRC_e::v1}; // FTM3CH1 pin is the output of FTM3 channel 1
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM3OCH2SRC_e : std::uint8_t
{
    v0 = 0, // FTM3CH2 pin is the output of FTM3 channel 2 PWM/OCMP
    v1 = 1  // FTM3CH2 pin is the output of FTM3 channel 2 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM3OCH2SRC_ = Field<FTM3OCH2SRC_e, Mask<18>{}, RW, struct SOPT9_>;
// FTM3 channel 2 output PWM/OCMP mode source select
struct FTM3OCH2SRC : FTM3OCH2SRC_ {
    explicit constexpr FTM3OCH2SRC(FTM3OCH2SRC_e value) : FTM3OCH2SRC_(value) {}
    static constexpr FTM3OCH2SRC_ v0{
        FTM3OCH2SRC_e::v0}; // FTM3CH2 pin is the output of FTM3 channel 2
                            // PWM/OCMP
    static constexpr FTM3OCH2SRC_ v1{
        FTM3OCH2SRC_e::v1}; // FTM3CH2 pin is the output of FTM3 channel 2
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM3OCH3SRC_e : std::uint8_t
{
    v0 = 0, // FTM3CH3 pin is the output of FTM3 channel 3 PWM/OCMP
    v1 = 1  // FTM3CH3 pin is the output of FTM3 channel 3 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM3OCH3SRC_ = Field<FTM3OCH3SRC_e, Mask<19>{}, RW, struct SOPT9_>;
// FTM3 channel 3 output PWM/OCMP mode source select
struct FTM3OCH3SRC : FTM3OCH3SRC_ {
    explicit constexpr FTM3OCH3SRC(FTM3OCH3SRC_e value) : FTM3OCH3SRC_(value) {}
    static constexpr FTM3OCH3SRC_ v0{
        FTM3OCH3SRC_e::v0}; // FTM3CH3 pin is the output of FTM3 channel 3
                            // PWM/OCMP
    static constexpr FTM3OCH3SRC_ v1{
        FTM3OCH3SRC_e::v1}; // FTM3CH3 pin is the output of FTM3 channel 3
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM3OCH4SRC_e : std::uint8_t
{
    v0 = 0, // FTM3CH4 pin is the output of FTM3 channel 4 PWM/OCMP
    v1 = 1  // FTM3CH4 pin is the output of FTM3 channel 4 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM3OCH4SRC_ = Field<FTM3OCH4SRC_e, Mask<20>{}, RW, struct SOPT9_>;
// FTM3 channel 4 output PWM/OCMP mode source select
struct FTM3OCH4SRC : FTM3OCH4SRC_ {
    explicit constexpr FTM3OCH4SRC(FTM3OCH4SRC_e value) : FTM3OCH4SRC_(value) {}
    static constexpr FTM3OCH4SRC_ v0{
        FTM3OCH4SRC_e::v0}; // FTM3CH4 pin is the output of FTM3 channel 4
                            // PWM/OCMP
    static constexpr FTM3OCH4SRC_ v1{
        FTM3OCH4SRC_e::v1}; // FTM3CH4 pin is the output of FTM3 channel 4
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM3OCH5SRC_e : std::uint8_t
{
    v0 = 0, // FTM3CH5 pin is the output of FTM3 channel 5 PWM/OCMP
    v1 = 1  // FTM3CH5 pin is the output of FTM3 channel 5 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM3OCH5SRC_ = Field<FTM3OCH5SRC_e, Mask<21>{}, RW, struct SOPT9_>;
// FTM3 channel 5 output PWM/OCMP mode source select
struct FTM3OCH5SRC : FTM3OCH5SRC_ {
    explicit constexpr FTM3OCH5SRC(FTM3OCH5SRC_e value) : FTM3OCH5SRC_(value) {}
    static constexpr FTM3OCH5SRC_ v0{
        FTM3OCH5SRC_e::v0}; // FTM3CH5 pin is the output of FTM3 channel 5
                            // PWM/OCMP
    static constexpr FTM3OCH5SRC_ v1{
        FTM3OCH5SRC_e::v1}; // FTM3CH5 pin is the output of FTM3 channel 5
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM4OCH0SRC_e : std::uint8_t
{
    v0 = 0, // FTM4CH0 pin is the output of FTM4 channel 0 PWM/OCMP
    v1 = 1  // FTM4CH0 pin is the output of FTM4 channel 0 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM4OCH0SRC_ = Field<FTM4OCH0SRC_e, Mask<22>{}, RW, struct SOPT9_>;
// FTM4 channel 0 output PWM/OCMP mode source select
struct FTM4OCH0SRC : FTM4OCH0SRC_ {
    explicit constexpr FTM4OCH0SRC(FTM4OCH0SRC_e value) : FTM4OCH0SRC_(value) {}
    static constexpr FTM4OCH0SRC_ v0{
        FTM4OCH0SRC_e::v0}; // FTM4CH0 pin is the output of FTM4 channel 0
                            // PWM/OCMP
    static constexpr FTM4OCH0SRC_ v1{
        FTM4OCH0SRC_e::v1}; // FTM4CH0 pin is the output of FTM4 channel 0
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};

enum class FTM4OCH1SRC_e : std::uint8_t
{
    v0 = 0, // FTM4CH1 pin is the output of FTM4 channel 1 PWM/OCMP
    v1 = 1  // FTM4CH1 pin is the output of FTM4 channel 1 PWM/OCMP modulating
            // the carrier frequency, as per CARRIER_SELECT1
};
using FTM4OCH1SRC_ = Field<FTM4OCH1SRC_e, Mask<23>{}, RW, struct SOPT9_>;
// FTM4 channel 1 output PWM/OCMP mode source select
struct FTM4OCH1SRC : FTM4OCH1SRC_ {
    explicit constexpr FTM4OCH1SRC(FTM4OCH1SRC_e value) : FTM4OCH1SRC_(value) {}
    static constexpr FTM4OCH1SRC_ v0{
        FTM4OCH1SRC_e::v0}; // FTM4CH1 pin is the output of FTM4 channel 1
                            // PWM/OCMP
    static constexpr FTM4OCH1SRC_ v1{
        FTM4OCH1SRC_e::v1}; // FTM4CH1 pin is the output of FTM4 channel 1
                            // PWM/OCMP modulating the carrier frequency, as per
                            // CARRIER_SELECT1
};
using reg = Register<std::uint32_t, 0x0, CARRIER_SELECT1_, FTM3OCH0SRC_,
                     FTM3OCH1SRC_, FTM3OCH2SRC_, FTM3OCH3SRC_, FTM3OCH4SRC_,
                     FTM3OCH5SRC_, FTM4OCH0SRC_, FTM4OCH1SRC_>;
} // namespace SOPT9_


inline namespace SDID_ {

enum class PINID_e : std::uint8_t
{
    v0010 = 2, // 32-pin
    v0100 = 4, // 48-pin
    v0101 = 5  // 64-pin
};
using PINID_ = Field<PINID_e, Mask<3, 0>{}, RO, struct SDID_>;
// Pincount identification
struct PINID : PINID_ {
    explicit constexpr PINID(PINID_e value) : PINID_(value) {}
    static constexpr PINID_ v0010{PINID_e::v0010}; // 32-pin
    static constexpr PINID_ v0100{PINID_e::v0100}; // 48-pin
    static constexpr PINID_ v0101{PINID_e::v0101}; // 64-pin
};

// Device die number
using DIEID = Field<std::uint8_t, Mask<11, 7>{}, RO, struct SDID_>;

// Device revision number
using REVID = Field<std::uint8_t, Mask<15, 12>{}, RO, struct SDID_>;

enum class SRAMSIZE_e : std::uint8_t
{
    v0101 = 5 // 16 KB
};
using SRAMSIZE_ = Field<SRAMSIZE_e, Mask<19, 16>{}, RO, struct SDID_>;
// Specifies the size of the System SRAM.
struct SRAMSIZE : SRAMSIZE_ {
    explicit constexpr SRAMSIZE(SRAMSIZE_e value) : SRAMSIZE_(value) {}
    static constexpr SRAMSIZE_ v0101{SRAMSIZE_e::v0101}; // 16 KB
};

enum class SERIERID_e : std::uint8_t
{
    v0110 = 6 // V-family - Motor control
};
using SERIERID_ = Field<SERIERID_e, Mask<23, 20>{}, RO, struct SDID_>;
// Series ID
struct SERIERID : SERIERID_ {
    explicit constexpr SERIERID(SERIERID_e value) : SERIERID_(value) {}
    static constexpr SERIERID_ v0110{
        SERIERID_e::v0110}; // V-family - Motor control
};

enum class SUBFAMID_e : std::uint8_t
{
    v0000 = 0, // MKV10xxxx
    v0001 = 1  // MKV11xxxx
};
using SUBFAMID_ = Field<SUBFAMID_e, Mask<27, 24>{}, RO, struct SDID_>;
// V Sub-family ID
struct SUBFAMID : SUBFAMID_ {
    explicit constexpr SUBFAMID(SUBFAMID_e value) : SUBFAMID_(value) {}
    static constexpr SUBFAMID_ v0000{SUBFAMID_e::v0000}; // MKV10xxxx
    static constexpr SUBFAMID_ v0001{SUBFAMID_e::v0001}; // MKV11xxxx
};

enum class FAMID_e : std::uint8_t
{
    v0001 = 1 // MKV1xZx
};
using FAMID_ = Field<FAMID_e, Mask<31, 28>{}, RO, struct SDID_>;
// V-Family ID
struct FAMID : FAMID_ {
    explicit constexpr FAMID(FAMID_e value) : FAMID_(value) {}
    static constexpr FAMID_ v0001{FAMID_e::v0001}; // MKV1xZx
};
using reg = Register<std::uint32_t, 0x10000000, PINID_, DIEID, REVID, SRAMSIZE_,
                     SERIERID_, SUBFAMID_, FAMID_>;
} // namespace SDID_


inline namespace SCGC4_ {

enum class EWM_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using EWM_ = Field<EWM_e, Mask<1>{}, RW, struct SCGC4_>;
// EWM Clock Gate Control
struct EWM : EWM_ {
    explicit constexpr EWM(EWM_e value) : EWM_(value) {}
    static constexpr EWM_ v0{EWM_e::v0}; // Clock disabled
    static constexpr EWM_ v1{EWM_e::v1}; // Clock enabled
};

enum class I2C0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using I2C0_ = Field<I2C0_e, Mask<6>{}, RW, struct SCGC4_>;
// I2C0 Clock Gate Control
struct I2C0 : I2C0_ {
    explicit constexpr I2C0(I2C0_e value) : I2C0_(value) {}
    static constexpr I2C0_ v0{I2C0_e::v0}; // Clock disabled
    static constexpr I2C0_ v1{I2C0_e::v1}; // Clock enabled
};

enum class UART0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using UART0_ = Field<UART0_e, Mask<10>{}, RW, struct SCGC4_>;
// UART0 Clock Gate Control
struct UART0 : UART0_ {
    explicit constexpr UART0(UART0_e value) : UART0_(value) {}
    static constexpr UART0_ v0{UART0_e::v0}; // Clock disabled
    static constexpr UART0_ v1{UART0_e::v1}; // Clock enabled
};

enum class UART1_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using UART1_ = Field<UART1_e, Mask<11>{}, RW, struct SCGC4_>;
// UART1 Clock Gate Control
struct UART1 : UART1_ {
    explicit constexpr UART1(UART1_e value) : UART1_(value) {}
    static constexpr UART1_ v0{UART1_e::v0}; // Clock disabled
    static constexpr UART1_ v1{UART1_e::v1}; // Clock enabled
};

enum class CMP_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using CMP_ = Field<CMP_e, Mask<19>{}, RW, struct SCGC4_>;
// Comparator Clock Gate Control
struct CMP : CMP_ {
    explicit constexpr CMP(CMP_e value) : CMP_(value) {}
    static constexpr CMP_ v0{CMP_e::v0}; // Clock disabled
    static constexpr CMP_ v1{CMP_e::v1}; // Clock enabled
};
using reg =
    Register<std::uint32_t, 0xF0000030, EWM_, I2C0_, UART0_, UART1_, CMP_>;
} // namespace SCGC4_


inline namespace SCGC5_ {

enum class LPTMR_e : std::uint8_t
{
    DISABLED = 0, // Access disabled
    ENABLED = 1   // Access enabled
};
using LPTMR_ = Field<LPTMR_e, Mask<0>{}, RW, struct SCGC5_>;
// Low Power Timer Clock Gate Control
struct LPTMR : LPTMR_ {
    explicit constexpr LPTMR(LPTMR_e value) : LPTMR_(value) {}
    static constexpr LPTMR_ DISABLED{LPTMR_e::DISABLED}; // Access disabled
    static constexpr LPTMR_ ENABLED{LPTMR_e::ENABLED};   // Access enabled
};

enum class PORTx_e : std::uint8_t
{
    DISABLED = 0, // Clock disabled
    ENABLED = 1   // Clock enabled
};
template <int n>
using PORTx_ = Field<PORTx_e, Mask<n + 9>{}, RW, struct SCGC5_>;
// Port A Clock Gate Control
template <int n>
struct PORTx : PORTx_<n> {
    explicit constexpr PORTx(PORTx_e value) : PORTx_(value) {}
    static constexpr PORTx_ DISABLED{PORTx_e::DISABLED}; // Clock disabled
    static constexpr PORTx_ ENABLED{PORTx_e::ENABLED};   // Clock enabled
};
using PORTA = PORTx<0> using PORTB = PORTx<1> using PORTC =
    PORTx<2> using PORTD = PORTx<3> using PORTE = PORTx<4> using reg =
        Register<std::uint32_t, 0x40180, LPTMR_, PORTx_<0>, PORTx_<1>,
                 PORTx_<2>, PORTx_<3>, PORTx_<4>>;
} // namespace SCGC5_


inline namespace SCGC6_ {

enum class FTF_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTF_ = Field<FTF_e, Mask<0>{}, RW, struct SCGC6_>;
// Flash Memory Clock Gate Control
struct FTF : FTF_ {
    explicit constexpr FTF(FTF_e value) : FTF_(value) {}
    static constexpr FTF_ v0{FTF_e::v0}; // Clock disabled
    static constexpr FTF_ v1{FTF_e::v1}; // Clock enabled
};

enum class DMAMUX_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using DMAMUX_ = Field<DMAMUX_e, Mask<1>{}, RW, struct SCGC6_>;
// DMA Mux Clock Gate Control
struct DMAMUX : DMAMUX_ {
    explicit constexpr DMAMUX(DMAMUX_e value) : DMAMUX_(value) {}
    static constexpr DMAMUX_ v0{DMAMUX_e::v0}; // Clock disabled
    static constexpr DMAMUX_ v1{DMAMUX_e::v1}; // Clock enabled
};

enum class FLEXCAN0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FLEXCAN0_ = Field<FLEXCAN0_e, Mask<4>{}, RW, struct SCGC6_>;
// FLEXCAN0 Clock Gate Control
struct FLEXCAN0 : FLEXCAN0_ {
    explicit constexpr FLEXCAN0(FLEXCAN0_e value) : FLEXCAN0_(value) {}
    static constexpr FLEXCAN0_ v0{FLEXCAN0_e::v0}; // Clock disabled
    static constexpr FLEXCAN0_ v1{FLEXCAN0_e::v1}; // Clock enabled
};

enum class FTM3_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTM3_ = Field<FTM3_e, Mask<6>{}, RW, struct SCGC6_>;
// FTM3 Clock Gate Control
struct FTM3 : FTM3_ {
    explicit constexpr FTM3(FTM3_e value) : FTM3_(value) {}
    static constexpr FTM3_ v0{FTM3_e::v0}; // Clock disabled
    static constexpr FTM3_ v1{FTM3_e::v1}; // Clock enabled
};

enum class FTM4_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTM4_ = Field<FTM4_e, Mask<7>{}, RW, struct SCGC6_>;
// FTM4 Clock Gate Control
struct FTM4 : FTM4_ {
    explicit constexpr FTM4(FTM4_e value) : FTM4_(value) {}
    static constexpr FTM4_ v0{FTM4_e::v0}; // Clock disabled
    static constexpr FTM4_ v1{FTM4_e::v1}; // Clock enabled
};

enum class FTM5_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTM5_ = Field<FTM5_e, Mask<8>{}, RW, struct SCGC6_>;
// FTM5 Clock Gate Control
struct FTM5 : FTM5_ {
    explicit constexpr FTM5(FTM5_e value) : FTM5_(value) {}
    static constexpr FTM5_ v0{FTM5_e::v0}; // Clock disabled
    static constexpr FTM5_ v1{FTM5_e::v1}; // Clock enabled
};

enum class SPI0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using SPI0_ = Field<SPI0_e, Mask<12>{}, RW, struct SCGC6_>;
// SPI0 Clock Gate Control
struct SPI0 : SPI0_ {
    explicit constexpr SPI0(SPI0_e value) : SPI0_(value) {}
    static constexpr SPI0_ v0{SPI0_e::v0}; // Clock disabled
    static constexpr SPI0_ v1{SPI0_e::v1}; // Clock enabled
};

enum class PDB1_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using PDB1_ = Field<PDB1_e, Mask<17>{}, RW, struct SCGC6_>;
// PDB1 Clock Gate Control
struct PDB1 : PDB1_ {
    explicit constexpr PDB1(PDB1_e value) : PDB1_(value) {}
    static constexpr PDB1_ v0{PDB1_e::v0}; // Clock disabled
    static constexpr PDB1_ v1{PDB1_e::v1}; // Clock enabled
};

enum class CRC_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using CRC_ = Field<CRC_e, Mask<18>{}, RW, struct SCGC6_>;
// CRC Clock Gate Control
struct CRC : CRC_ {
    explicit constexpr CRC(CRC_e value) : CRC_(value) {}
    static constexpr CRC_ v0{CRC_e::v0}; // Clock disabled
    static constexpr CRC_ v1{CRC_e::v1}; // Clock enabled
};

enum class PDB0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using PDB0_ = Field<PDB0_e, Mask<22>{}, RW, struct SCGC6_>;
// PDB0 Clock Gate Control
struct PDB0 : PDB0_ {
    explicit constexpr PDB0(PDB0_e value) : PDB0_(value) {}
    static constexpr PDB0_ v0{PDB0_e::v0}; // Clock disabled
    static constexpr PDB0_ v1{PDB0_e::v1}; // Clock enabled
};

enum class FTM0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTM0_ = Field<FTM0_e, Mask<24>{}, RW, struct SCGC6_>;
// FTM0 Clock Gate Control
struct FTM0 : FTM0_ {
    explicit constexpr FTM0(FTM0_e value) : FTM0_(value) {}
    static constexpr FTM0_ v0{FTM0_e::v0}; // Clock disabled
    static constexpr FTM0_ v1{FTM0_e::v1}; // Clock enabled
};

enum class FTM1_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTM1_ = Field<FTM1_e, Mask<25>{}, RW, struct SCGC6_>;
// FTM1 Clock Gate Control
struct FTM1 : FTM1_ {
    explicit constexpr FTM1(FTM1_e value) : FTM1_(value) {}
    static constexpr FTM1_ v0{FTM1_e::v0}; // Clock disabled
    static constexpr FTM1_ v1{FTM1_e::v1}; // Clock enabled
};

enum class FTM2_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using FTM2_ = Field<FTM2_e, Mask<26>{}, RW, struct SCGC6_>;
// FTM2 Clock Gate Control
struct FTM2 : FTM2_ {
    explicit constexpr FTM2(FTM2_e value) : FTM2_(value) {}
    static constexpr FTM2_ v0{FTM2_e::v0}; // Clock disabled
    static constexpr FTM2_ v1{FTM2_e::v1}; // Clock enabled
};

enum class ADC0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using ADC0_ = Field<ADC0_e, Mask<27>{}, RW, struct SCGC6_>;
// ADC0 Clock Gate Control
struct ADC0 : ADC0_ {
    explicit constexpr ADC0(ADC0_e value) : ADC0_(value) {}
    static constexpr ADC0_ v0{ADC0_e::v0}; // Clock disabled
    static constexpr ADC0_ v1{ADC0_e::v1}; // Clock enabled
};

enum class ADC1_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using ADC1_ = Field<ADC1_e, Mask<28>{}, RW, struct SCGC6_>;
// ADC1 Clock Gate Control
struct ADC1 : ADC1_ {
    explicit constexpr ADC1(ADC1_e value) : ADC1_(value) {}
    static constexpr ADC1_ v0{ADC1_e::v0}; // Clock disabled
    static constexpr ADC1_ v1{ADC1_e::v1}; // Clock enabled
};

enum class DAC0_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using DAC0_ = Field<DAC0_e, Mask<31>{}, RW, struct SCGC6_>;
// DAC0 Clock Gate Control
struct DAC0 : DAC0_ {
    explicit constexpr DAC0(DAC0_e value) : DAC0_(value) {}
    static constexpr DAC0_ v0{DAC0_e::v0}; // Clock disabled
    static constexpr DAC0_ v1{DAC0_e::v1}; // Clock enabled
};
using reg = Register<std::uint32_t, 0x1, FTF_, DMAMUX_, FLEXCAN0_, FTM3_, FTM4_,
                     FTM5_, SPI0_, PDB1_, CRC_, PDB0_, FTM0_, FTM1_, FTM2_,
                     ADC0_, ADC1_, DAC0_>;
} // namespace SCGC6_


inline namespace SCGC7_ {

enum class DMA_e : std::uint8_t
{
    v0 = 0, // Clock disabled
    v1 = 1  // Clock enabled
};
using DMA_ = Field<DMA_e, Mask<8>{}, RW, struct SCGC7_>;
// DMA Clock Gate Control
struct DMA : DMA_ {
    explicit constexpr DMA(DMA_e value) : DMA_(value) {}
    static constexpr DMA_ v0{DMA_e::v0}; // Clock disabled
    static constexpr DMA_ v1{DMA_e::v1}; // Clock enabled
};
using reg = Register<std::uint32_t, 0x100, DMA_>;
} // namespace SCGC7_


inline namespace CLKDIV1_ {

enum class OUTDIV5_e : std::uint8_t
{
    DIV_BY_1 = 0, // Divide-by-1
    DIV_BY_2 = 1, // Divide-by-2
    DIV_BY_3 = 2, // Divide-by-3
    DIV_BY_4 = 3, // Divide-by-4
    DIV_BY_5 = 4, // Divide-by-5
    DIV_BY_6 = 5, // Divide-by-6
    DIV_BY_7 = 6, // Divide-by-7
    DIV_BY_8 = 7  // Divide-by-8
};
using OUTDIV5_ = Field<OUTDIV5_e, Mask<14, 12>{}, RW, struct CLKDIV1_>;
// Clock 5 Output Divider Value
struct OUTDIV5 : OUTDIV5_ {
    explicit constexpr OUTDIV5(OUTDIV5_e value) : OUTDIV5_(value) {}
    static constexpr OUTDIV5_ DIV_BY_1{OUTDIV5_e::DIV_BY_1}; // Divide-by-1
    static constexpr OUTDIV5_ DIV_BY_2{OUTDIV5_e::DIV_BY_2}; // Divide-by-2
    static constexpr OUTDIV5_ DIV_BY_3{OUTDIV5_e::DIV_BY_3}; // Divide-by-3
    static constexpr OUTDIV5_ DIV_BY_4{OUTDIV5_e::DIV_BY_4}; // Divide-by-4
    static constexpr OUTDIV5_ DIV_BY_5{OUTDIV5_e::DIV_BY_5}; // Divide-by-5
    static constexpr OUTDIV5_ DIV_BY_6{OUTDIV5_e::DIV_BY_6}; // Divide-by-6
    static constexpr OUTDIV5_ DIV_BY_7{OUTDIV5_e::DIV_BY_7}; // Divide-by-7
    static constexpr OUTDIV5_ DIV_BY_8{OUTDIV5_e::DIV_BY_8}; // Divide-by-8
};

enum class OUTDIV5EN_e : std::uint8_t
{
    DISABLED = 0, // OUTDIV5 disabled
    ENABLED = 1   // OUTDIV5 enabled
};
using OUTDIV5EN_ = Field<OUTDIV5EN_e, Mask<15>{}, RW, struct CLKDIV1_>;
// OUTDIV5 Divider Control
struct OUTDIV5EN : OUTDIV5EN_ {
    explicit constexpr OUTDIV5EN(OUTDIV5EN_e value) : OUTDIV5EN_(value) {}
    static constexpr OUTDIV5EN_ DISABLED{
        OUTDIV5EN_e::DISABLED}; // OUTDIV5 disabled
    static constexpr OUTDIV5EN_ ENABLED{
        OUTDIV5EN_e::ENABLED}; // OUTDIV5 enabled
};

enum class OUTDIV4_e : std::uint8_t
{
    DIV_BY_1 = 0, // Divide-by-1.
    DIV_BY_2 = 1, // Divide-by-2.
    DIV_BY_3 = 2, // Divide-by-3.
    DIV_BY_4 = 3, // Divide-by-4.
    DIV_BY_5 = 4, // Divide-by-5.
    DIV_BY_6 = 5, // Divide-by-6.
    DIV_BY_7 = 6, // Divide-by-7.
    DIV_BY_8 = 7  // Divide-by-8.
};
using OUTDIV4_ = Field<OUTDIV4_e, Mask<18, 16>{}, RW, struct CLKDIV1_>;
// Clock 4 Output Divider Value
struct OUTDIV4 : OUTDIV4_ {
    explicit constexpr OUTDIV4(OUTDIV4_e value) : OUTDIV4_(value) {}
    static constexpr OUTDIV4_ DIV_BY_1{OUTDIV4_e::DIV_BY_1}; // Divide-by-1.
    static constexpr OUTDIV4_ DIV_BY_2{OUTDIV4_e::DIV_BY_2}; // Divide-by-2.
    static constexpr OUTDIV4_ DIV_BY_3{OUTDIV4_e::DIV_BY_3}; // Divide-by-3.
    static constexpr OUTDIV4_ DIV_BY_4{OUTDIV4_e::DIV_BY_4}; // Divide-by-4.
    static constexpr OUTDIV4_ DIV_BY_5{OUTDIV4_e::DIV_BY_5}; // Divide-by-5.
    static constexpr OUTDIV4_ DIV_BY_6{OUTDIV4_e::DIV_BY_6}; // Divide-by-6.
    static constexpr OUTDIV4_ DIV_BY_7{OUTDIV4_e::DIV_BY_7}; // Divide-by-7.
    static constexpr OUTDIV4_ DIV_BY_8{OUTDIV4_e::DIV_BY_8}; // Divide-by-8.
};

enum class OUTDIV1_e : std::uint8_t
{
    DIV_BY_1 = 0,   // Divide-by-1.
    DIV_BY_2 = 1,   // Divide-by-2.
    DIV_BY_3 = 2,   // Divide-by-3.
    DIV_BY_4 = 3,   // Divide-by-4.
    DIV_BY_5 = 4,   // Divide-by-5.
    DIV_BY_6 = 5,   // Divide-by-6.
    DIV_BY_7 = 6,   // Divide-by-7.
    DIV_BY_8 = 7,   // Divide-by-8.
    DIV_BY_9 = 8,   // Divide-by-9.
    DIV_BY_10 = 9,  // Divide-by-10.
    DIV_BY_11 = 10, // Divide-by-11.
    DIV_BY_12 = 11, // Divide-by-12.
    DIV_BY_13 = 12, // Divide-by-13.
    DIV_BY_14 = 13, // Divide-by-14.
    DIV_BY_15 = 14, // Divide-by-15.
    DIV_BY_16 = 15  // Divide-by-16.
};
using OUTDIV1_ = Field<OUTDIV1_e, Mask<31, 28>{}, RW, struct CLKDIV1_>;
// Clock 1 Output Divider Value
struct OUTDIV1 : OUTDIV1_ {
    explicit constexpr OUTDIV1(OUTDIV1_e value) : OUTDIV1_(value) {}
    static constexpr OUTDIV1_ DIV_BY_1{OUTDIV1_e::DIV_BY_1};   // Divide-by-1.
    static constexpr OUTDIV1_ DIV_BY_2{OUTDIV1_e::DIV_BY_2};   // Divide-by-2.
    static constexpr OUTDIV1_ DIV_BY_3{OUTDIV1_e::DIV_BY_3};   // Divide-by-3.
    static constexpr OUTDIV1_ DIV_BY_4{OUTDIV1_e::DIV_BY_4};   // Divide-by-4.
    static constexpr OUTDIV1_ DIV_BY_5{OUTDIV1_e::DIV_BY_5};   // Divide-by-5.
    static constexpr OUTDIV1_ DIV_BY_6{OUTDIV1_e::DIV_BY_6};   // Divide-by-6.
    static constexpr OUTDIV1_ DIV_BY_7{OUTDIV1_e::DIV_BY_7};   // Divide-by-7.
    static constexpr OUTDIV1_ DIV_BY_8{OUTDIV1_e::DIV_BY_8};   // Divide-by-8.
    static constexpr OUTDIV1_ DIV_BY_9{OUTDIV1_e::DIV_BY_9};   // Divide-by-9.
    static constexpr OUTDIV1_ DIV_BY_10{OUTDIV1_e::DIV_BY_10}; // Divide-by-10.
    static constexpr OUTDIV1_ DIV_BY_11{OUTDIV1_e::DIV_BY_11}; // Divide-by-11.
    static constexpr OUTDIV1_ DIV_BY_12{OUTDIV1_e::DIV_BY_12}; // Divide-by-12.
    static constexpr OUTDIV1_ DIV_BY_13{OUTDIV1_e::DIV_BY_13}; // Divide-by-13.
    static constexpr OUTDIV1_ DIV_BY_14{OUTDIV1_e::DIV_BY_14}; // Divide-by-14.
    static constexpr OUTDIV1_ DIV_BY_15{OUTDIV1_e::DIV_BY_15}; // Divide-by-15.
    static constexpr OUTDIV1_ DIV_BY_16{OUTDIV1_e::DIV_BY_16}; // Divide-by-16.
};
using reg =
    Register<std::uint32_t, 0x11000, OUTDIV5_, OUTDIV5EN_, OUTDIV4_, OUTDIV1_>;
} // namespace CLKDIV1_


inline namespace FCFG1_ {

enum class FLASHDIS_e : std::uint8_t
{
    v0 = 0, // Flash is enabled
    v1 = 1  // Flash is disabled
};
using FLASHDIS_ = Field<FLASHDIS_e, Mask<0>{}, RW, struct FCFG1_>;
// Flash Disable
struct FLASHDIS : FLASHDIS_ {
    explicit constexpr FLASHDIS(FLASHDIS_e value) : FLASHDIS_(value) {}
    static constexpr FLASHDIS_ v0{FLASHDIS_e::v0}; // Flash is enabled
    static constexpr FLASHDIS_ v1{FLASHDIS_e::v1}; // Flash is disabled
};

enum class FLASHDOZE_e : std::uint8_t
{
    v0 = 0, // Flash remains enabled during Doze mode
    v1 = 1  // Flash is disabled for the duration of Doze mode
};
using FLASHDOZE_ = Field<FLASHDOZE_e, Mask<1>{}, RW, struct FCFG1_>;
// Flash Doze
struct FLASHDOZE : FLASHDOZE_ {
    explicit constexpr FLASHDOZE(FLASHDOZE_e value) : FLASHDOZE_(value) {}
    static constexpr FLASHDOZE_ v0{
        FLASHDOZE_e::v0}; // Flash remains enabled during Doze mode
    static constexpr FLASHDOZE_ v1{
        FLASHDOZE_e::v1}; // Flash is disabled for the duration of Doze mode
};

enum class PFSIZE_e : std::uint8_t
{
    v0000 = 0, // 8 KB of program flash memory, 0.25 KB protection region
    v0001 = 1, // 16 KB of program flash memory, 0.5 KB protection region
    v0011 = 3, // 32 KB of program flash memory, 1 KB protection region
    v0101 = 5, // 64 KB of program flash memory, 2 KB protection region
    v0111 = 7, // 128 KB of program flash memory, 4 KB protection region
    v1001 = 9, // 256 KB of program flash memory, 4 KB protection region
    v1111 = 15 // 32 KB of program flash memory, 1 KB protection region
};
using PFSIZE_ = Field<PFSIZE_e, Mask<27, 24>{}, RO, struct FCFG1_>;
// Program Flash Size
struct PFSIZE : PFSIZE_ {
    explicit constexpr PFSIZE(PFSIZE_e value) : PFSIZE_(value) {}
    static constexpr PFSIZE_ v0000{
        PFSIZE_e::v0000}; // 8 KB of program flash memory, 0.25 KB protection
                          // region
    static constexpr PFSIZE_ v0001{
        PFSIZE_e::v0001}; // 16 KB of program flash memory, 0.5 KB protection
                          // region
    static constexpr PFSIZE_ v0011{
        PFSIZE_e::v0011}; // 32 KB of program flash memory, 1 KB protection
                          // region
    static constexpr PFSIZE_ v0101{
        PFSIZE_e::v0101}; // 64 KB of program flash memory, 2 KB protection
                          // region
    static constexpr PFSIZE_ v0111{
        PFSIZE_e::v0111}; // 128 KB of program flash memory, 4 KB protection
                          // region
    static constexpr PFSIZE_ v1001{
        PFSIZE_e::v1001}; // 256 KB of program flash memory, 4 KB protection
                          // region
    static constexpr PFSIZE_ v1111{
        PFSIZE_e::v1111}; // 32 KB of program flash memory, 1 KB protection
                          // region
};
using reg = Register<std::uint32_t, 0x0, FLASHDIS_, FLASHDOZE_, PFSIZE_>;
} // namespace FCFG1_


inline namespace FCFG2_ {

// Max address block
using MAXADDR = Field<std::uint8_t, Mask<30, 24>{}, RO, struct FCFG2_>;
using reg = Register<std::uint32_t, 0x800000, MAXADDR>;
} // namespace FCFG2_


inline namespace UIDMH_ {

// Unique Identification
using UID = Field<std::uint16_t, Mask<15, 0>{}, RO, struct UIDMH_>;
using reg = Register<std::uint32_t, 0x0, UID>;
} // namespace UIDMH_


inline namespace UIDML_ {

// Unique Identification
using UID = Field<std::uint32_t, Mask<31, 0>{}, RO, struct UIDML_>;
using reg = Register<std::uint32_t, 0x0, UID>;
} // namespace UIDML_


inline namespace UIDL_ {

// Unique Identification
using UID = Field<std::uint32_t, Mask<31, 0>{}, RO, struct UIDL_>;
using reg = Register<std::uint32_t, 0x0, UID>;
} // namespace UIDL_


inline namespace WDOGC_ {

enum class WDOGCLKS_e : std::uint8_t
{
    v0 = 0, // Internal 1 kHz clock is source to WDOG
    v1 = 1  // MCGIRCLK is source to WDOG
};
using WDOGCLKS_ = Field<WDOGCLKS_e, Mask<1>{}, RW, struct WDOGC_>;
// WDOG Clock Select
struct WDOGCLKS : WDOGCLKS_ {
    explicit constexpr WDOGCLKS(WDOGCLKS_e value) : WDOGCLKS_(value) {}
    static constexpr WDOGCLKS_ v0{
        WDOGCLKS_e::v0}; // Internal 1 kHz clock is source to WDOG
    static constexpr WDOGCLKS_ v1{WDOGCLKS_e::v1}; // MCGIRCLK is source to WDOG
};
using reg = Register<std::uint32_t, 0x0, WDOGCLKS_>;
} // namespace WDOGC_


struct SIM_t {
    SOPT1_::reg SOPT1; // System Options Register 1
    padding<4096> Reserved_0;
    SOPT2_::reg SOPT2; // System Options Register 2
    padding<4> Reserved_1;
    SOPT4_::reg SOPT4; // System Options Register 4
    SOPT5_::reg SOPT5; // System Options Register 5
    SOPT6_::reg SOPT6; // Systems Option Register 6
    SOPT7_::reg SOPT7; // System Options Register 7
    SOPT8_::reg SOPT8; // System Options Register 8
    SOPT9_::reg SOPT9; // System Options Register 9
    SDID_::reg SDID;   // System Device Identification Register
    padding<12> Reserved_2;
    SCGC4_::reg SCGC4;     // System Clock Gating Control Register 4
    SCGC5_::reg SCGC5;     // System Clock Gating Control Register 5
    SCGC6_::reg SCGC6;     // System Clock Gating Control Register 6
    SCGC7_::reg SCGC7;     // System Clock Gating Control Register 7
    CLKDIV1_::reg CLKDIV1; // System Clock Divider Register 1
    padding<4> Reserved_3;
    FCFG1_::reg FCFG1; // Flash Configuration Register 1
    FCFG2_::reg FCFG2; // Flash Configuration Register 2
    padding<4> Reserved_4;
    UIDMH_::reg UIDMH; // Unique Identification Register Mid-High
    UIDML_::reg UIDML; // Unique Identification Register Mid Low
    UIDL_::reg UIDL;   // Unique Identification Register Low
    padding<156> Reserved_5;
    WDOGC_::reg WDOGC; // WDOG Control Register
};

} // namespace SIM
} // namespace MKV11Z7

#endif // MKV11Z7_SIM_HPP