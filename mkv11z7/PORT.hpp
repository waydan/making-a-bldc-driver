// This file was automatically generated by the Regilite generator


#ifndef MKV11Z7_PORT_HPP
#define MKV11Z7_PORT_HPP

#include <cstdint>
#include <regilite/default_register.hpp>
#include <regilite/field.hpp>


namespace MKV11Z7 {
inline namespace PORT {


inline namespace PCRn_ {

enum class PS_e : std::uint8_t
{
    pulldown = 0, // Internal pulldown resistor is enabled on the corresponding
                  // pin, if the corresponding PE field is set.
    pullup = 1 // Internal pullup resistor is enabled on the corresponding pin,
               // if the corresponding PE field is set.
};
using PS_ = Field<PS_e, Mask<0>{}, RW, struct PCR0_>;
// Pull Select
struct PS : PS_ {
    explicit constexpr PS(PS_e value) : PS_(value) {}
    static constexpr PS_ pulldown{
        PS_e::pulldown}; // Internal pulldown resistor is enabled on the
                         // corresponding pin, if the corresponding PE field is
                         // set.
    static constexpr PS_ pullup{
        PS_e::pullup}; // Internal pullup resistor is enabled on the
                       // corresponding pin, if the corresponding PE field is
                       // set.
};

enum class PE_e : std::uint8_t
{
    disabled = 0, // Internal pullup or pulldown resistor is not enabled on the
                  // corresponding pin.
    enabled =
        1 // Internal pullup or pulldown resistor is enabled on the
          // corresponding pin, if the pin is configured as a digital input.
};
using PE_ = Field<PE_e, Mask<1>{}, RW, struct PCR0_>;
// Pull Enable
struct PE : PE_ {
    explicit constexpr PE(PE_e value) : PE_(value) {}
    static constexpr PE_ disabled{
        PE_e::disabled}; // Internal pullup or pulldown resistor is not enabled
                         // on the corresponding pin.
    static constexpr PE_ enabled{
        PE_e::enabled}; // Internal pullup or pulldown resistor is enabled on
                        // the corresponding pin, if the pin is configured as a
                        // digital input.
};

enum class SRE_e : std::uint8_t
{
    fast_slew = 0, // Fast slew rate is configured on the corresponding pin, if
                   // the pin is configured as a digital output.
    slow_slew = 1 // Slow slew rate is configured on the corresponding pin, if
                  // the pin is configured as a digital output.
};
using SRE_ = Field<SRE_e, Mask<2>{}, RW, struct PCR0_>;
// Slew Rate Enable
struct SRE : SRE_ {
    explicit constexpr SRE(SRE_e value) : SRE_(value) {}
    static constexpr SRE_ fast_slew{
        SRE_e::fast_slew}; // Fast slew rate is configured on the corresponding
                           // pin, if the pin is configured as a digital output.
    static constexpr SRE_ slow_slew{
        SRE_e::slow_slew}; // Slow slew rate is configured on the corresponding
                           // pin, if the pin is configured as a digital output.
};

enum class PFE_e : std::uint8_t
{
    disabled = 0, // Passive input filter is disabled on the corresponding pin.
    enabled = 1 // Passive input filter is enabled on the corresponding pin, if
                // the pin is configured as a digital input. Refer to the device
                // data sheet for filter characteristics.
};
using PFE_ = Field<PFE_e, Mask<4>{}, RO, struct PCR0_>;
// Passive Filter Enable
struct PFE : PFE_ {
    explicit constexpr PFE(PFE_e value) : PFE_(value) {}
    static constexpr PFE_ disabled{
        PFE_e::disabled}; // Passive input filter is disabled on
                          // the corresponding pin.
    static constexpr PFE_ enabled{
        PFE_e::enabled}; // Passive input filter is enabled on the corresponding
                         // pin, if the pin is configured as a digital input.
                         // Refer to the device data sheet for filter
                         // characteristics.
};

enum class DSE_e : std::uint8_t
{
    low_strength = 0, // Low drive strength is configured on the corresponding
                      // pin, if pin is configured as a digital output.
    high_strength = 1 // High drive strength is configured on the corresponding
                      // pin, if pin is configured as a digital output.
};
using DSE_ = Field<DSE_e, Mask<6>{}, RO, struct PCR0_>;
// Drive Strength Enable
struct DSE : DSE_ {
    explicit constexpr DSE(DSE_e value) : DSE_(value) {}
    static constexpr DSE_ low_strength{
        DSE_e::low_strength}; // Low drive strength is configured on the
                              // corresponding pin, if pin is configured as a
                              // digital output.
    static constexpr DSE_ high_strength{
        DSE_e::high_strength}; // High drive strength is configured on the
                               // corresponding pin, if pin is configured as a
                               // digital output.
};

enum class MUX_e : std::uint8_t
{
    Alt0 = 0, // Pin disabled (analog).
    Alt1 = 1, // Alternative 1 (GPIO).
    Alt2 = 2, // Alternative 2 (chip-specific).
    Alt3 = 3, // Alternative 3 (chip-specific).
    Alt4 = 4, // Alternative 4 (chip-specific).
    Alt5 = 5, // Alternative 5 (chip-specific).
    Alt6 = 6, // Alternative 6 (chip-specific).
    Alt7 = 7  // Alternative 7 (chip-specific).
};
using MUX_ = Field<MUX_e, Mask<10, 8>{}, RW, struct PCR0_>;
// Pin Mux Control
struct MUX : MUX_ {
    explicit constexpr MUX(MUX_e value) : MUX_(value) {}
    static constexpr MUX_ Alt0{MUX_e::Alt0}; // Pin disabled (analog).
    static constexpr MUX_ Alt1{MUX_e::Alt1}; // Alternative 1 (GPIO).
    static constexpr MUX_ Alt2{MUX_e::Alt2}; // Alternative 2 (chip-specific).
    static constexpr MUX_ Alt3{MUX_e::Alt3}; // Alternative 3 (chip-specific).
    static constexpr MUX_ Alt4{MUX_e::Alt4}; // Alternative 4 (chip-specific).
    static constexpr MUX_ Alt5{MUX_e::Alt5}; // Alternative 5 (chip-specific).
    static constexpr MUX_ Alt6{MUX_e::Alt6}; // Alternative 6 (chip-specific).
    static constexpr MUX_ Alt7{MUX_e::Alt7}; // Alternative 7 (chip-specific).
};

enum class IRQC_e : std::uint8_t
{
    disabled = 0,                   // Interrupt Status Flag (ISF) is disabled.
    dma_on_rising_edge = 1,         // ISF flag and DMA request on rising edge.
    dma_on_falling_edge = 2,        // ISF flag and DMA request on falling edge.
    dma_on_either_edge = 3,         // ISF flag and DMA request on either edge.
    interrupt_on_logic_0 = 8,       // ISF flag and Interrupt when logic 0.
    interrupt_on_rising_edge = 9,   // ISF flag and Interrupt on rising-edge.
    interrupt_on_falling_edge = 10, // ISF flag and Interrupt on falling-edge.
    interrupt_on_either_edge = 11,  // ISF flag and Interrupt on either edge.
    interrupt_on_logic_1 = 12       // ISF flag and Interrupt when logic 1.
};
using IRQC_ = Field<IRQC_e, Mask<19, 16>{}, RW, struct PCR0_>;
// Interrupt Configuration
struct IRQC : IRQC_ {
    explicit constexpr IRQC(IRQC_e value) : IRQC_(value) {}
    static constexpr IRQC_ disabled{
        IRQC_e::disabled}; // Interrupt Status Flag (ISF) is disabled.
    static constexpr IRQC_ dma_on_rising_edge{
        IRQC_e::dma_on_rising_edge}; // ISF flag and DMA request on rising edge.
    static constexpr IRQC_ dma_on_falling_edge{
        IRQC_e::dma_on_falling_edge}; // ISF flag and DMA request on falling
                                      // edge.
    static constexpr IRQC_ dma_on_either_edge{
        IRQC_e::dma_on_either_edge}; // ISF flag and DMA request on either edge.
    static constexpr IRQC_ interrupt_on_logic_0{
        IRQC_e::interrupt_on_logic_0}; // ISF flag and Interrupt when logic 0.
    static constexpr IRQC_ interrupt_on_rising_edge{
        IRQC_e::interrupt_on_rising_edge}; // ISF flag and Interrupt on
                                           // rising-edge.
    static constexpr IRQC_ interrupt_on_falling_edge{
        IRQC_e::interrupt_on_falling_edge}; // ISF flag and Interrupt on
                                            // falling-edge.
    static constexpr IRQC_ interrupt_on_either_edge{
        IRQC_e::interrupt_on_either_edge}; // ISF flag and Interrupt on either
                                           // edge.
    static constexpr IRQC_ interrupt_on_logic_1{
        IRQC_e::interrupt_on_logic_1}; // ISF flag and Interrupt when logic 1.
};

enum class ISF_e : std::uint8_t
{
    not_detected = 0, // Configured interrupt is not detected.
    detected =
        1 // Configured interrupt is detected. If the pin is configured to
          // generate a DMA request, then the corresponding flag will be
          // cleared automatically at the completion of the requested DMA
          // transfer. Otherwise, the flag remains set until a logic 1 is
          // written to the flag. If the pin is configured for a level
    // sensitive interrupt and the pin remains asserted, then the flag is
    // set again immediately after it is cleared.
};
using ISF_ = Field<ISF_e, Mask<24>{}, RW, struct PCR0_>;
// Interrupt Status Flag
struct ISF : ISF_ {
    explicit constexpr ISF(ISF_e value) : ISF_(value) {}
    static constexpr ISF_ not_detected{
        ISF_e::not_detected}; // Configured interrupt is not detected.
    static constexpr ISF_ detected{
        ISF_e::detected}; // Configured interrupt is detected. If the pin is
                          // configured to generate a DMA request, then the
                          // corresponding flag will be cleared automatically at
                          // the completion of the requested DMA transfer.
                          // Otherwise, the flag remains set until a logic 1 is
                          // written to the flag. If the pin is configured for a
                          // level sensitive interrupt and the pin remains
                          // asserted, then the flag is set again immediately
                          // after it is cleared.
};
using reg = Register<std::uint32_t, 0x702, PS_, PE_, SRE_, PFE_, DSE_, MUX_,
                     IRQC_, ISF_>;
} // namespace PCRn_


inline namespace GPCxR_ {

// Global Pin Write Data
using GPWD = Field<std::uint16_t, Mask<15, 0>{}, WO, struct GPCLR_>;

enum class GPWEn_e : std::uint8_t
{
    not_update_pcr = 0, // Corresponding Pin Control Register is not updated
                        // with the value in GPWD.
    update_pcr = 1 // Corresponding Pin Control Register is updated with the
                   // value in GPWD.
};
template <int n>
using GPWEn_ = Field<GPWEn_e, Mask<n + 16>{}, WO, struct GPCLR_>;
// Global Pin Write Enable
template <int n>
struct GPWEn : GPWEn_<n> {
    explicit constexpr GPWEn(GPWEn_e value) : GPWEn_(value) {}
    static constexpr GPWEn_ not_update_pcr{
        GPWEn_e::not_update_pcr}; // Corresponding Pin Control Register is not
                                  // updated with the value in GPWD.
    static constexpr GPWEn_ update_pcr{
        GPWEn_e::update_pcr}; // Corresponding Pin Control Register is updated
                              // with the value in GPWD.
};
using reg = Register<std::uint32_t, 0x0, GPWD, GPWEn_<0>, GPWEn_<1>, GPWEn_<2>,
                     GPWEn_<3>, GPWEn_<4>, GPWEn_<5>, GPWEn_<6>, GPWEn_<7>,
                     GPWEn_<8>, GPWEn_<9>, GPWEn_<10>, GPWEn_<11>, GPWEn_<12>,
                     GPWEn_<13>, GPWEn_<14>, GPWEn_<15>>;
} // namespace GPCxR_


inline namespace ISFR_ {

enum class ISFn_e : std::uint8_t
{
    not_detected = 0, // Configured interrupt is not detected.
    detected =
        1 // Configured interrupt is detected. If the pin is configured to
          // generate a DMA request, then the corresponding flag will be
          // cleared automatically at the completion of the requested DMA
          // transfer. Otherwise, the flag remains set until a logic 1 is
          // written to the flag. If the pin is configured for a level
    // sensitive interrupt and the pin remains asserted, then the flag is
    // set again immediately after it is cleared.
};
template <int n>
using ISFn_ = Field<ISFn_e, Mask<n>{}, RW, struct ISFR_>;
// Interrupt Status Flag
template <int n>
struct ISFn : ISFn_<n> {
    explicit constexpr ISFn(ISFn_e value) : ISFn_(value) {}
    static constexpr ISFn_ not_detected{
        ISFn_e::not_detected}; // Configured interrupt is not detected.
    static constexpr ISFn_ detected{
        ISFn_e::detected}; // Configured interrupt is detected. If the pin is
                           // configured to generate a DMA request, then the
                           // corresponding flag will be cleared automatically
                           // at the completion of the requested DMA transfer.
                           // Otherwise, the flag remains set until a logic 1 is
                           // written to the flag. If the pin is configured for
                           // a level sensitive interrupt and the pin remains
                           // asserted, then the flag is set again immediately
                           // after it is cleared.
};
using reg =
    Register<std::uint32_t, 0x0, ISFn_<0>, ISFn_<1>, ISFn_<2>, ISFn_<3>,
             ISFn_<4>, ISFn_<5>, ISFn_<6>, ISFn_<7>, ISFn_<8>, ISFn_<9>,
             ISFn_<10>, ISFn_<11>, ISFn_<12>, ISFn_<13>, ISFn_<14>, ISFn_<15>,
             ISFn_<16>, ISFn_<17>, ISFn_<18>, ISFn_<19>, ISFn_<20>, ISFn_<21>,
             ISFn_<22>, ISFn_<23>, ISFn_<24>, ISFn_<25>, ISFn_<26>, ISFn_<27>,
             ISFn_<28>, ISFn_<29>, ISFn_<30>, ISFn_<31>>;
} // namespace ISFR_


struct PORT_t {
    PCRn_::reg PCR[32]; // Pin Control Register n
    GPCxR_::reg GPCLR;  // Global Pin Control Low Register
    GPCxR_::reg GPCHR;  // Global Pin Control High Register
    padding<24> Reserved_0;
    ISFR_::reg ISFR; // Interrupt Status Flag Register
};

} // namespace PORT
} // namespace MKV11Z7

#endif // MKV11Z7_PORT_HPP